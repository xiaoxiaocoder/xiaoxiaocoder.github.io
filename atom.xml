<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhaoyan&#39;s github page</title>
  
  <subtitle>生命不息,折腾不止!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xiaoxiaocoder.github.io/"/>
  <updated>2017-12-09T06:32:33.000Z</updated>
  <id>https://xiaoxiaocoder.github.io/</id>
  
  <author>
    <name>Zhao Yan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[TypeScript 19]手册指南: 三斜线指令</title>
    <link href="https://xiaoxiaocoder.github.io/programming/javascript/typescript/2017-08-27-typescript-19-triple-salash-directives.html"/>
    <id>https://xiaoxiaocoder.github.io/programming/javascript/typescript/2017-08-27-typescript-19-triple-salash-directives.html</id>
    <published>2017-08-27T08:00:32.000Z</published>
    <updated>2017-12-09T06:32:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>三斜线指令是包含单个XML标签的单行注释. 注释的内容会作为编译器指令使用.</p><p>三斜线指令仅可放在包含它的文件的最顶端. 一个三斜线指令的前面只能出现单行或多行注释,这包括其他的三斜线指令. 如果他们出现在一个语句或声明之后,那么它们会被当做普通的单行注释,并且不具有特殊的含义.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">///&lt;reference path=&quot;...&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>///<reference path="...">指令是三斜线指令中最常见的一种. 它用于声明文件间的依赖.</reference></p><p>三斜线引用告诉编译器在编译过程中要引入的额外的文件.</p><a id="more"></a><p>当使用–out或–outFile时, 它也可以作为调整输出内容顺序的一种方法. 文件在输出文件内容中的位置与经过预处理后的输入顺序一致.</p><h2 id="预处理输入文件"><a href="#预处理输入文件" class="headerlink" title="预处理输入文件"></a>预处理输入文件</h2><p>编译器会对输入文件进行预处理来解析所有三斜线引用指令. 在这个过程中, 额外的文件会加到编译过程中.</p><p>这个过程会以一些根文件开始; 它们是在命名行中指定的文件或是在tsconfig.json中的”files”列表里的文件. 这些根文件指定的顺序进行预处理. 在一个文件被加入列表前, 它包含的所有三斜线引用都要被处理,还有它们包含的目标. 三斜线引用以它们在文件里出现的顺序, 使用深度优先的方式解析.</p><p>一个三斜线引用路径是相对于包含它的文件的, 如果不是根文件.</p><h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>引用不存在的文件会报错. 一个文件用三斜线指令引用自己会报错.</p><h2 id="使用-–noResolve"><a href="#使用-–noResolve" class="headerlink" title="使用 –noResolve"></a>使用 –noResolve</h2><p>如果指定了–noResolve编译选项, 三斜线引用会被忽略; 它们不会增加新文件, 也不会改变给定文件的顺序.</p><p>///<reference types="..."><br>与///<reference path="...">指令相似, 这个指令是用来声明依赖的; 一个///<reference path="..."> 指令声明了对@types包的一个依赖.</reference></reference></reference></p><p>在声明文件里包含///<reference types="node">, 表明这个文件使用了@types/node/index.d.ts里声明的名字; 并且,这个包要在编译阶段与声明文件一起被包含进来.</reference></p><p>解析@types包的名字的过程与解析import语句里模块名的过程类似. 所以可以简单的把三斜线类型引用指令想象成针对包的import声明.</p><p>仅当你需要一个d.ts文件时才能使用这个指令.</p><p>对于那些在编译阶段生成的声明文件,编译器会自动添加///<reference types="...">; 当且仅当结果文件中使用了引用的@types包里的声明才会在生成的声明文件里添加///<reference types="...">语句.</reference></reference></p><p>若要在.ts文件里声明一个对@types包的依赖,使用 –types命令行选项火灾tsconfig.json里指定. 查看在tsconfig.json里使用@types, typeRoots和types了解详情.</p><p>///<reference no-default-lib="true"><br>这个指令吧一个文件标记成默认库, 你会在lib.d.ts文件和它不同的变体的井段看到这个注释.</reference></p><p>这个指令告诉编译器在编译过程中不要包含这个默认库(比如, lib.d.ts). 这与在命令行使用 –noLib相似.</p><p>还要注意, 当传递了 –skipDefaultLibCheck时, 编译器只会忽略检查带有 ///<refenence no-default-lib="true">的文件.</refenence></p><p>///<amd-module><br>默认情况下生成的AMD模块都是匿名的. 但是,当一些工具需要处理生成的模块时会产生问题, 比如 r.js<br>amd-module指令允许给编译器传入一个可选的模块名.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//amdModule.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt;amd-module name="NamedModule" /&gt;</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></amd-module></p><p>这回将NamedModule传入到AMD define函数里.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//amdModule.js</span></span><br><span class="line">define(<span class="string">"NamedModule"</span>,[<span class="string">"require"</span>,<span class="string">"exports"</span>],<span class="function"><span class="keyword">function</span>(<span class="params">require,exports</span>))</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> C =(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">return</span> C;</span><br><span class="line">    &#125;)();</span><br><span class="line"></span><br><span class="line">    exports.C =C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>///<amd-dependency></amd-dependency></p><blockquote><p>注意, 这个指令被废弃了, 使用import “moduleName”; 语句替代.</p></blockquote><p>///<amd-dependency path="x"> 告诉编译器有一个非TypeScript模块需要被注入, 作为目标模块require调用的一部分.</amd-dependency></p><p>amd-dependency指令也可以待一个可选的name属性;它允许我们为amd-dependency传入一个可选名字<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///&lt;amd-dependency path="legacy/moduleA" name="moduleA" /&gt;</span></span><br><span class="line">declare <span class="keyword">var</span> moduleA: myType</span><br><span class="line"><span class="built_in">module</span>.callStuff*(</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成的Javascript代码:</span></span><br><span class="line">define([<span class="string">"require"</span>,<span class="string">"exports"</span>,<span class="string">"legacy/moduleA"</span>],<span class="function"><span class="keyword">function</span>(<span class="params">require,exports, moduleA</span>))</span>&#123;</span><br><span class="line">    moduleA.callStuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>The End!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;三斜线指令是包含单个XML标签的单行注释. 注释的内容会作为编译器指令使用.&lt;/p&gt;
&lt;p&gt;三斜线指令仅可放在包含它的文件的最顶端. 一个三斜线指令的前面只能出现单行或多行注释,这包括其他的三斜线指令. 如果他们出现在一个语句或声明之后,那么它们会被当做普通的单行注释,并且不具有特殊的含义.&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;///&amp;lt;reference path=&amp;quot;...&amp;quot; /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;///&lt;reference path=&quot;...&quot;&gt;指令是三斜线指令中最常见的一种. 它用于声明文件间的依赖.&lt;/reference&gt;&lt;/p&gt;
&lt;p&gt;三斜线引用告诉编译器在编译过程中要引入的额外的文件.&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="https://xiaoxiaocoder.github.io/categories/programming/"/>
    
      <category term="javascript" scheme="https://xiaoxiaocoder.github.io/categories/programming/javascript/"/>
    
      <category term="typescript" scheme="https://xiaoxiaocoder.github.io/categories/programming/javascript/typescript/"/>
    
    
      <category term="typescript" scheme="https://xiaoxiaocoder.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>[TypeScript 18]手册指南: Mixins</title>
    <link href="https://xiaoxiaocoder.github.io/programming/javascript/typescript/2017-08-27-typescript-18-mixins.html"/>
    <id>https://xiaoxiaocoder.github.io/programming/javascript/typescript/2017-08-27-typescript-18-mixins.html</id>
    <published>2017-08-27T05:58:46.000Z</published>
    <updated>2017-12-09T06:32:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>除了传统的面向对象继承方式, 还流行一种通过可重用组件创建组件的方式, 就是联合另一个简单的类的代码. </p><h2 id="混入示例"><a href="#混入示例" class="headerlink" title="混入示例"></a>混入示例</h2><p>下面的代码演示了如何在TypeScript里使用混入.</p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//disposable Mixin</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Disposable</span></span>&#123;</span><br><span class="line">    isDisposed: boolean;</span><br><span class="line">    dispose()&#123;</span><br><span class="line">        <span class="keyword">this</span>.isDisposed =<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Activatable Mixin</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Activatable</span> </span>&#123;</span><br><span class="line">    isActive: boolean;</span><br><span class="line">    activate()&#123;</span><br><span class="line">        <span class="keyword">this</span>.isActive =<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    deactivate()&#123;</span><br><span class="line">        <span class="keyword">this</span>.isActive = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartObject</span> <span class="title">implements</span> <span class="title">Disposable</span>, <span class="title">Activatable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        setInterval(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="keyword">this</span>.isActive+ <span class="string">" : "</span>+ <span class="keyword">this</span>.isDisposed),<span class="number">500</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    interact()&#123;</span><br><span class="line">        <span class="keyword">this</span>.activate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Disposable</span></span><br><span class="line">    isDisposed: boolean =<span class="literal">false</span>;</span><br><span class="line">    dispose:<span class="function"><span class="params">()</span> =&gt;</span><span class="keyword">void</span>;</span><br><span class="line">    <span class="comment">//Activatable</span></span><br><span class="line">    isActive: boolean= <span class="literal">false</span>;</span><br><span class="line">    active: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">void</span>;</span><br><span class="line">    deactivate: <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">applyMixins(SmartObject,[Disposable,Activatable]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> smartObj =<span class="keyword">new</span> SmartObject();</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>smartObj.interact(),<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//In your runtime library somewhere</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyMixins</span>(<span class="params">dervedCtor: any, baseCtors: anyp[]</span>)</span>&#123;</span><br><span class="line">    baseCtors.forEach(<span class="function"><span class="params">baseCtor</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">Object</span>.getOwnPropertyNames(baseCtor.prototype).forEach(<span class="function"><span class="params">name</span>=&gt;</span>&#123;</span><br><span class="line">            derivedCtor.prototype[name]=baseCtor.prototype[name];</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="理解这个例子"><a href="#理解这个例子" class="headerlink" title="理解这个例子"></a>理解这个例子</h2><p>代码里首先定义两个类, 它们将作为mixins. 可以看到每个类都之定义了一个特定的行为或功能.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Disposable Mixin</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Disposable</span> </span>&#123;</span><br><span class="line">    isDisposed: boolean;</span><br><span class="line">    dispose()&#123;</span><br><span class="line">        <span class="keyword">this</span>.isDisposed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Activatable Mixin</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Activatable</span></span>&#123;</span><br><span class="line">    isActive: boolean;</span><br><span class="line">    active()&#123;</span><br><span class="line">        <span class="keyword">this</span>.isActive = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    deactivate()&#123;</span><br><span class="line">        <span class="keyword">this</span>.isActive =<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面创建一个类, 结合了这两个mixins.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartObject</span> <span class="title">implements</span> <span class="title">Disposable</span>, <span class="title">Activatable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>首先应该注意到的是, 没有使用extends而是使用implements. 把类当成了接口, 仅使用Disposable和Activatable的类型而非实现, 这意味着我们需要在类里面实现接口. 但是这是我们在用mixin时想避免的.</p><p>我们可以这么做来达到目的, 为将要mixin进行的属性方法创建出占位属性. 这告诉编译器这些成员在运行时是可用的. 这样就能使用mixin带来的便利, 虽然需要七千定义一些占位符<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Disposable</span></span><br><span class="line">isDisposed: booleab =<span class="literal">false</span>;</span><br><span class="line">dispose() : <span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Activatable</span></span><br><span class="line">isActive: boolean =<span class="literal">false</span>;</span><br><span class="line">active: <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">void</span>;</span><br><span class="line">deactivate: <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">void</span>;</span><br></pre></td></tr></table></figure></p><p>最后, 把mixins混去定义的类,完成全部实现部分.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">applyMixins(SmartObject, [Disposable, Activatable]);</span><br></pre></td></tr></table></figure></p><p>最后, 创建这个帮助函数, 帮我们做混入操作. 它会便利mixins上的所有属性,并复制到目标上去,把之前的占位属性替换成真正的实现代码.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyMixins</span>(<span class="params">derivedCtor: any, baseCtor: any[]</span>)</span>&#123;</span><br><span class="line">    baseCtors.forEach(<span class="function"><span class="params">baseCtor</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">Object</span>.getOwnPropertyNames(baseCtor.prototype).forEach(<span class="function"><span class="params">name</span>=&gt;</span>&#123;</span><br><span class="line">            derivedCtor.prototype[Name]= baseCtor.Prototype[name]</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>The End!</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;除了传统的面向对象继承方式, 还流行一种通过可重用组件创建组件的方式, 就是联合另一个简单的类的代码. &lt;/p&gt;
&lt;h2 id=&quot;混入示例&quot;&gt;&lt;a href=&quot;#混入示例&quot; class=&quot;headerlink&quot; title=&quot;混入示例&quot;&gt;&lt;/a&gt;混入示例&lt;/h2&gt;&lt;p&gt;下面的代码演示了如何在TypeScript里使用混入.&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="https://xiaoxiaocoder.github.io/categories/programming/"/>
    
      <category term="javascript" scheme="https://xiaoxiaocoder.github.io/categories/programming/javascript/"/>
    
      <category term="typescript" scheme="https://xiaoxiaocoder.github.io/categories/programming/javascript/typescript/"/>
    
    
      <category term="typescript" scheme="https://xiaoxiaocoder.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>[TypeScript 17]手册指南: 装饰器</title>
    <link href="https://xiaoxiaocoder.github.io/programming/javascript/typescript/2017-08-25-typescript-17-decoarators.html"/>
    <id>https://xiaoxiaocoder.github.io/programming/javascript/typescript/2017-08-25-typescript-17-decoarators.html</id>
    <published>2017-08-25T13:02:02.000Z</published>
    <updated>2017-12-09T06:32:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>随着TypeScript和ES6里引入类, 在一些场景下我们需要额外的特性来支持标注或修改类及其成员. 装饰器(Decorators) 为我们在类的声明及成员上通过元编程语法添加标注提供了一种方式. Javascript里的装饰器目前处于 <a href="https://github.com/tc39/proposal-decorators" target="_blank" rel="noopener">建议征集的第二阶段</a>, 但在TypeScript里以作为一项实现性特性予以支持.</p><blockquote><p>注意: 装饰器是一项实验性特性,在未来的版本中可能会发生改变.</p></blockquote><p>若要启用实验性的装饰器特性, 必须在命令行或tsconfig.json里启用expreimentalDecorators编译器选项.</p><a id="more"></a><p><strong>命令行</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --target ES5 --expreimentalDecorators</span><br></pre></td></tr></table></figure></p><p><strong>tsconfig.json</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;complierOptions&quot;:&#123;</span><br><span class="line">        &quot;target&quot;:&quot;ES5&quot;,</span><br><span class="line">        &quot;experimentalDecorators&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>装饰器是一种特殊类型的声明, 它能够被附加到类声明,方法, 访问符, 属性或参数上. 装饰器使用@expression这种形式, expression求值后必须为一个函数, 它会在运行时被调用, 被装饰的声明信息作为参数传入.</p><p>例如, 有一个@sealed 装饰器, 我们会这样定义sealed函数:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sealed</span>(<span class="params">target</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//do something with "target" ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="装饰器工厂"><a href="#装饰器工厂" class="headerlink" title="装饰器工厂"></a>装饰器工厂</h3><p>如果我们要定制一个修士器如何应用到一个声明上, 我们得写一个装饰器工厂函数.  装饰器工厂就是一个简单的函数,它返回一个表达式,以供装饰器在运行时调用.</p><p>我们可以通过下面的方式来写一个装饰器工厂函数:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">color</span>(<span class="params">value: string</span>) </span>&#123; <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target</span>)</span>&#123; <span class="comment">//装饰器</span></span><br><span class="line">        <span class="comment">//do something with target and value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="装饰器组合"><a href="#装饰器组合" class="headerlink" title="装饰器组合"></a>装饰器组合</h3><p>多个装饰器可以同时应用到一个声明上,就像下面的示例:</p><ul><li>书写在同一行上:<br><code>@f @g x</code></li><li>书写在多行上<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@f</span><br><span class="line">@g</span><br><span class="line">x</span><br></pre></td></tr></table></figure></li></ul><p>当多个装饰器应用于一个声明上,它们求值方式与复合函数相似. 在这个模型下, 当复合f 和g时, 复合的结果(f.g)(x)等同于f(g(x))<br>同样的, 在TypeScript里, 当多个装饰器应用在一个声明上时会进行如下步骤的操作:</p><ol><li>由上至下一次对装饰器表达式求值</li><li>求值的结果会被当做函数,由下至上一次调用.</li></ol><p>如果我们使用装饰器工厂的话, 可以通过下面的例子来观察它们求值的顺序:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"f(): evaluated"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target,propertyKey:string,descriptor:PropertyDescriptor</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"f(): called"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"g() : evaluated"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target, property: string, descriptor: PropertyDescriptor</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"g() :called"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    @f()</span><br><span class="line">    @g()</span><br><span class="line">    method()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在控制台里会打印出如下结果:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f(): evaluated</span><br><span class="line">g(): evaluated</span><br><span class="line">g(): called</span><br><span class="line">f(): called</span><br></pre></td></tr></table></figure></p><h3 id="装饰器求值"><a href="#装饰器求值" class="headerlink" title="装饰器求值"></a>装饰器求值</h3><p>类中不同声明上的装饰器将按以下顺序应用</p><ol><li>参数装饰器, 然后依次是方法装饰器,访问符装饰器,或属性装饰器应用到每个实例成员.</li><li>参数装饰器,然后依次是方法装饰器,访问符修饰器,或属性装饰器应用到每个静态成员.</li><li>参数装饰器应用到构造函数</li><li>类装饰器应用到类</li></ol><h3 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h3><p>类装饰器在类声明之前被声明(紧靠着类声明). 类装饰器应用于类构造函数, 可以用来见识,修改或替换类定义. 类装饰器不能用在声明文件中(.d.ts), 也不能用在任何外部上下文中(如declare的类).</p><p>类装饰器表达式会在运行时当做函数调用,类的构造函数作为其唯一的参数.</p><p>如果类装饰器返回一个值, 它会使用提供的构造函数来替换类的声明.</p><blockquote><p>注意: 如果你要返回一个新的构造函数, 你必须注意处理好原来的原型链. 在运行时的装饰器调用逻辑中 不会为你做这些.</p></blockquote><p>下面是使用类装饰器(@sealed)的例子, 应用在Greeter类<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@sealed</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeter</span> </span>&#123;</span><br><span class="line">    greeting: string;</span><br><span class="line">    <span class="keyword">constructor</span>(message: string)&#123;</span><br><span class="line">        <span class="keyword">this</span>.greeting= message;</span><br><span class="line">    &#125;</span><br><span class="line">    greet()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello, "</span>+ <span class="keyword">this</span>.greeting;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以这样定义@sealed装饰器:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sealed</span>(<span class="params">constructor: Function</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.seal(<span class="keyword">constructor</span>);</span><br><span class="line">    Object.seal(<span class="keyword">constructor</span>.prototype)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当@sealed被执行时,它将密封此类的构造函数. (注: 参见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/seal" target="_blank" rel="noopener">Object.seal</a>)</p><p>下面是一个重载构造器函数的例子/<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">classDecorator</span>&lt;<span class="title">T</span> <span class="title">extends</span> </span>&#123;<span class="keyword">new</span>(...args:any[])&#125;&gt;(<span class="keyword">constructor</span>:T)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">constructor</span> </span>&#123;</span><br><span class="line">        newProperty=<span class="string">"new Property"</span>;</span><br><span class="line">        hello=<span class="string">"override"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@classDecorator</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gretter</span></span>&#123;</span><br><span class="line">    property=<span class="string">"property"</span>;</span><br><span class="line">    hello: string;</span><br><span class="line">    <span class="keyword">constructor</span>(m:string)&#123;</span><br><span class="line">        <span class="keyword">this</span>.hello =m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Greeter(<span class="string">"world!"</span>));</span><br></pre></td></tr></table></figure></p><h3 id="方法装饰器"><a href="#方法装饰器" class="headerlink" title="方法装饰器"></a>方法装饰器</h3><p>方法装饰器声明在一个方法的声明之前(紧靠着方法声明). 它会被应用到方法的属性描述符上, 可以用来监视, 修改或替换方法定义. 方法修饰符不能用在声明文件(.d.ts), 重载或任何外部上下文(如declare的类)中.</p><p>方法装饰器表达式会在运行时当做函数被调用, 传入下列3个参数:</p><ol><li>对于静态成员来说是类的构造函数,对于实例成员是类的原型对象.</li><li>成员的名字</li><li>成员的属性描述符</li></ol><blockquote><p>注意, 如果代码输出目标版本小于ES5, 属性描述符将会是undefined.</p></blockquote><p>如果方法装饰器返回一个值,它会被用作方法的属性描述符.</p><blockquote><p>注意, 如果代码输出目标版本ES5, 返回值会被忽略</p></blockquote><p>下面是一个方法装饰器(@enumerable)的例子,<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gretter</span></span>&#123;</span><br><span class="line">    greeting: string;</span><br><span class="line">    <span class="keyword">constructor</span>(message: string)&#123;</span><br><span class="line">        <span class="keyword">this</span>.greeting =message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @enumable(<span class="literal">false</span>)</span><br><span class="line">    greet()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, "</span>+ <span class="keyword">this</span>.greeting;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enumable</span>(<span class="params">value: boolean</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target:any, propertyKey : string, descriptor: PropertyDescriptor</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> descriptor.enumable= value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的@enumable(false)是一个装饰器工厂. 当装饰器@enumable(false)被调用时, 它会修改属性描述符enumable属性.</p><h3 id="访问器装饰器"><a href="#访问器装饰器" class="headerlink" title="访问器装饰器"></a>访问器装饰器</h3><p>访问器装饰器声明在一个访问器的声明之前(紧靠着访问器声明). 访问器装饰器应用于访问器的 <strong>属性描述符</strong>并且可以用来监视,修改或替换一个访问器的定义. 访问器装饰器补鞥用在声明文件中(.d.ts), 或者任何外部上下文(如declare的类)里.</p><blockquote><p>注意, TypeScript不允许同时装饰一个成员的get和set访问器. 取而代之的是,一个成员的所有装饰器必须应用在文档顺序的第二访问器上. 这是因为, 在装饰器应用一个属性描述符时, 它联合了get和set访问器,而不是分开声明的.</p></blockquote><p>访问器装饰器表达式会在运行时当做函数被调用,传入下列3个参数:</p><ol><li>对于静态成员来说是类的构造函数, 对于静态成员是类的原型对象</li><li>成员的名字</li><li>成员的属性描述符<blockquote><p>注意, 如果代码输出目标版本小于ES5, property Descriptor将会是undefined.</p></blockquote></li></ol><p>如果访问器返回一个值,它会被用作方法的属性描述符</p><blockquote><p>注意, 如果代码输出目标小于ES5返回值会被忽略.</p></blockquote><p>下面使用了访问器装饰器(@configurable)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    private _x :number;</span><br><span class="line">    private _y :number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(x: number, y:number)&#123;</span><br><span class="line">        <span class="keyword">this</span>._x =x;</span><br><span class="line">        <span class="keyword">this</span>._y=y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @configurable(<span class="literal">false</span>)</span><br><span class="line">    get x()&#123;<span class="keyword">return</span> <span class="keyword">this</span>._x;&#125;</span><br><span class="line"></span><br><span class="line">    @configurable(<span class="literal">false</span>)</span><br><span class="line">    get y()&#123;<span class="keyword">return</span> <span class="keyword">this</span>._y;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@configurable声明如下</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">configurable</span>(<span class="params">value: boolean</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target: any, propertyKey: string, descriptor: PropertyDescriptor</span>)</span>&#123;</span><br><span class="line">        descriptor.configurable =value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="属性装饰器"><a href="#属性装饰器" class="headerlink" title="属性装饰器"></a>属性装饰器</h3><p>属性装饰器声明在一个属性声明之前(紧靠着属性声明). 属性装饰器不能用在声明文件中(.d.ts), 或者任何外部上下文(如 declare的类)里.</p><p>属相装饰器表达式会在运行时当做函数被调用, 传入下列2个参数:</p><ol><li>对于静态成员来说是类的构造函数,对于实例成员是类的原型对象.</li><li>成员的名字.</li></ol><blockquote><p>注意, <em>属性描述符</em>不会作为参数传入属性装饰器, 这与TypeScript是如何初始化属相装饰器的有关. 因为目前没有办法在定义一个原型对象的成员时描述一个实例属性, 并且没有办法监视或修改一个属性的初始化方法. 因此,属性描述符只能用来监视类是否声明了某个名字的属性.</p></blockquote><p>如果属性装饰器返回一个值, 它会被用作方法的属性描述符.</p><blockquote><p>注意, 如果代码输出目标小于ES5,返回值会被忽略.<br>如果访问符装饰器返回一个值,它会被用作方法的属性描述符.</p></blockquote><p>我们可以用它来记录这个属性的元数据.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeter</span> </span>&#123;</span><br><span class="line">    @format(<span class="string">"hello, s%"</span>)</span><br><span class="line">    greeting: string;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(message: string)&#123;</span><br><span class="line">        <span class="keyword">this</span>.greeting =message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    greet()&#123;</span><br><span class="line">        <span class="keyword">let</span> formatString= getFormat(<span class="keyword">this</span>, <span class="string">"greeting"</span>);</span><br><span class="line">        <span class="keyword">return</span> formatString.replace(<span class="string">"%s"</span>,<span class="keyword">this</span>.greeting);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义@format装饰器和getFormat函数</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'reflect-metadata'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> formatMetadataKey = <span class="built_in">Symbol</span>(<span class="string">"format"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">format</span>(<span class="params">formatString: string</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.metadata(formatMetadataKey,formatString);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFormat</span>(<span class="params">target: any, propertyKey :string</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.getMetadata(formatMetadataKey,target, propertyKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个@format(“Hello, %s”)装饰器是个<a href="https://www.tslang.cn/docs/handbook/decorators.html#decorator-factories" target="_blank" rel="noopener">装饰器工厂</a>. 当@format(“Hello, %s”)被调用时, 它添加一条这个属性的元数据, 通过reflect-metadata库里Reflect.metadata函数. 当getFormat被调用时, 它读取格式的元数据.</p><blockquote><p>注意, 这个例子需要使用reflect-metadata库,查看<a href="https://www.tslang.cn/docs/handbook/decorators.html#metadata" target="_blank" rel="noopener">元数据</a>了解reflect-metadata库更详细的信息.</p></blockquote><h3 id="参数装饰器"><a href="#参数装饰器" class="headerlink" title="参数装饰器"></a>参数装饰器</h3><p>参数装饰器声明在一个参数声明之前(紧靠着参数声明). 参数装饰器应用于类的构造器函数或方法声明. 参数砖石漆不能用在声明文件(.d.ts), 重载或其他外部上下文(如declare类)里.</p><p>参数装饰器表达式会在运行时当做函数被调用, 传入下列3个参数.</p><ol><li>对于静态成员来说是类的构造函数,对于实例成员是类的原型对象</li><li>成员的名字.</li><li>参数在函数参数列表中的索引.</li></ol><blockquote><p>注意, 参数装饰器只能用来监视一个方法的参数是否被传入.</p></blockquote><p>参数装饰器的返回值会被忽略.</p><p>下列定义了参数装饰器(@required)并应用于Greeter类方法的一个参数:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeter</span> </span>&#123;</span><br><span class="line">    greeting: stringl</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(message : string)&#123;</span><br><span class="line">        <span class="keyword">this</span>.greeting=message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @validate</span><br><span class="line">    greet(@required name: string)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span>+ name +<span class="string">", "</span>+<span class="keyword">this</span>.greeting;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的函数定义 @required和 @validate装饰器</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'reflect-metadata'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> requiredMetadataKey= <span class="built_in">Symbol</span>(<span class="string">"required"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">required</span>(<span class="params">target: Object, propertyKey: string | symbol, parameterIndex: number</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> existingRequiredParameters: number[] =<span class="built_in">Reflect</span>.getOwnMetadata(requiredMetadataKey, target, propertyKey) || [];</span><br><span class="line">    existingRequiredParameters.push(parameterIndex);</span><br><span class="line">    <span class="built_in">Reflect</span>.defineMetadata(requiredMetadataKey,existingRequiredParameters,target,propertyKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validate</span>(<span class="params">target: any, propertyName: string, descriptor: TypedPropertyDescriptor&lt;Function&gt;</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> method=descriptor.value;</span><br><span class="line">    descriptor.value=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> requiredParameters: number[] =<span class="built_in">Reflect</span>.getOwnMetadata(requiredMetadataKey,target, propertyName);</span><br><span class="line">        <span class="keyword">if</span>(requiredParameters)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> parameterIndex <span class="keyword">of</span> requiredParameters)&#123;</span><br><span class="line">                <span class="keyword">if</span>(parameterIndex &gt;= <span class="built_in">arguments</span>.length || <span class="built_in">arguments</span>[parameterIndex]===<span class="literal">undefined</span>)&#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Missing required argument."</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> method.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>@required装饰器添加了元数据实体吧参数标记为必需的. @validate装饰器把greet方法包裹在一个函数里在调用原先的函数验证函数参数.</p><blockquote><p>注意, 这个例子使用了reflect-metadata库. 查看<a href="https://www.tslang.cn/docs/handbook/decorators.html#metadata" target="_blank" rel="noopener">元数据</a>库的更多信息.</p></blockquote><h3 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h3><p>一些椅子使用了reflect-metadata库来支持实验性的metadata API. 这个库还不是ECMAScript(javascript)标准的一部分. 然而,当装饰器被ECMAScript官方标准采纳后, 这些扩展也将被推荐给ECMAScript以采纳.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i reflect-metadaa --save</span><br></pre></td></tr></table></figure><p>TypeScript支持为带有装饰器的声明生成元数据. 你需要在命令行货tsconfig.json里启用emitDecoratorMetadata编译器选项</p><p>Command Line<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --target ES5 --experimentalDecorators --emitDecoratorMetadata</span><br></pre></td></tr></table></figure></p><p>tsconfig.json<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"compilerOptions"</span>:&#123;</span><br><span class="line">        <span class="attr">"target"</span>:<span class="string">"ES5"</span>,</span><br><span class="line">        <span class="attr">"experimentalDecorators"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"emitDecoratorMetadata"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当启用后, 只要reflect-metadata库被引入了. 设计阶段添加的类型信息可以在运行时使用.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"reflect-metadata"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">    x: number;</span><br><span class="line">    y: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span> </span>&#123;</span><br><span class="line">    private _p0: Point;</span><br><span class="line">    private _p1: Point;</span><br><span class="line"></span><br><span class="line">    @validate</span><br><span class="line">    set po(value: Point)&#123;<span class="keyword">this</span>._p0=value&#125;</span><br><span class="line">    get p0()&#123;<span class="keyword">return</span> <span class="keyword">this</span>._p0;&#125;</span><br><span class="line"></span><br><span class="line">    @validate</span><br><span class="line">    set p1(value: Point)&#123;<span class="keyword">this</span>._p1 =value;&#125;</span><br><span class="line">    get p1()&#123;<span class="keyword">return</span> <span class="keyword">this</span>._p1;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validate</span>&lt;<span class="title">T</span>&gt;(<span class="params">target: any, propertyKey: string, descriptor: TypedPropertyDescriptor&lt;T&gt;</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> set=descriptor.set;</span><br><span class="line">    descriptor.set =<span class="function"><span class="keyword">function</span>(<span class="params">value: T</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> type= <span class="built_in">Reflect</span>.getMetadata(<span class="string">"design: type"</span>,target, propertyKey);</span><br><span class="line">        <span class="keyword">if</span>(!(value <span class="keyword">instanceof</span> type))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Invalid type."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        set(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>TypeScript编译器可以通过@Reflect.metadata装饰器注意设计阶段的类型信息.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span></span>&#123;</span><br><span class="line">    private _p0: Point;</span><br><span class="line">    private _p1: Point;</span><br><span class="line"></span><br><span class="line">    @validate</span><br><span class="line">    @<span class="built_in">Reflect</span>.metadata(<span class="string">"design:type"</span>,Point)</span><br><span class="line">    set p0(value:Point)&#123;<span class="keyword">this</span>._p0 =value;&#125;</span><br><span class="line">    get p0()&#123;<span class="keyword">return</span> <span class="keyword">this</span>._p0;&#125;</span><br><span class="line"></span><br><span class="line">    @validate</span><br><span class="line">    @<span class="built_in">Reflect</span>.metadata(<span class="string">"design:type"</span>, Point)</span><br><span class="line">    set p1(value:Point)&#123;<span class="keyword">this</span>._p1= value;&#125;</span><br><span class="line">    get p1()&#123;<span class="keyword">return</span> <span class="keyword">this</span>._p1;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>注意, 装饰器元数据是个实验性的特性并且可能在以后的版本中发生破坏性的改变(breaking changes).</p></blockquote><p>The End!</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;随着TypeScript和ES6里引入类, 在一些场景下我们需要额外的特性来支持标注或修改类及其成员. 装饰器(Decorators) 为我们在类的声明及成员上通过元编程语法添加标注提供了一种方式. Javascript里的装饰器目前处于 &lt;a href=&quot;https://github.com/tc39/proposal-decorators&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;建议征集的第二阶段&lt;/a&gt;, 但在TypeScript里以作为一项实现性特性予以支持.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意: 装饰器是一项实验性特性,在未来的版本中可能会发生改变.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;若要启用实验性的装饰器特性, 必须在命令行或tsconfig.json里启用expreimentalDecorators编译器选项.&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="https://xiaoxiaocoder.github.io/categories/programming/"/>
    
      <category term="javascript" scheme="https://xiaoxiaocoder.github.io/categories/programming/javascript/"/>
    
      <category term="typescript" scheme="https://xiaoxiaocoder.github.io/categories/programming/javascript/typescript/"/>
    
    
      <category term="typescript" scheme="https://xiaoxiaocoder.github.io/tags/typescript/"/>
    
      <category term="decorators" scheme="https://xiaoxiaocoder.github.io/tags/decorators/"/>
    
  </entry>
  
  <entry>
    <title>[TypeScript 16]手册指南: JSX</title>
    <link href="https://xiaoxiaocoder.github.io/programming/javascript/typescript/2017-08-24-typescript-16-jsx.html"/>
    <id>https://xiaoxiaocoder.github.io/programming/javascript/typescript/2017-08-24-typescript-16-jsx.html</id>
    <published>2017-08-24T04:01:03.000Z</published>
    <updated>2017-12-09T06:32:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>JSX是一种嵌入式的类似xml的语法. 它可以被转换成合法的JavaScript, 尽管转换的语义是根据不同的实现而定的. JSX因React框架而流行, 但是也被其他应用所使用. TypeScript支持内嵌,类型检核和将JSX直接便以为Javascript.</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>使用JSX必须做两件事:</p><ol><li>给文件一个.tsx扩展名</li><li>启用jsx选项</li></ol><a id="more"></a><p>TypeScript具有三种JSX模式: preserve, react和react-native. 这些模式只在代码生成阶段起作用-类型检查并不受影响.<br>在preserve模式下生成代码中会保留JSX以供后续的转换操作使用.(如babel),另外,输出文件会带有.jsx扩展名.<br>react模式会成成React.createElement,在使用前不需要再进行转换操作了,输出文件扩展名为.js<br>react-native相当于preserve,它也保留了所有的JSX, 但是输出文件的扩展名为.js</p><table><thead><tr><th>模式</th><th>输入</th><th>输出</th><th>输出文件扩展名</th></tr></thead><tbody><tr><td>preserve</td><td>&lt; div /&gt;</td><td>&lt; div /&gt;</td><td>.jsx</td></tr><tr><td>react</td><td>&lt; div/&gt;</td><td>React.createElement(“div”)</td><td>.js</td></tr><tr><td>react-native</td><td>&lt; div/&gt;</td><td>&lt; div/&gt;</td><td>.js</td></tr></tbody></table><p>你可以通过在命令号使用 –jsx标记或tsconfig.json里的选项来指定模式.</p><blockquote><p>注意: React标识符是写死的硬编码,所以你必须保证React(R大写)是可用的.</p></blockquote><h2 id="as-操作符"><a href="#as-操作符" class="headerlink" title="as 操作符"></a>as 操作符</h2><p>回想一下怎么写类型断言:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="xml"><span class="tag">&lt;<span class="name">foo</span>&gt;</span> bar;</span></span><br></pre></td></tr></table></figure></p><p>这里我们断言bar变量时foo类型的. 因为TypeScript也是用尖括号来表示积累选哪个断言, JSX的语法带来了解析的困难. 因此, TypeScript在.tsx文件里禁用了尖括号的类型断言.<br>为了弥补.tsx里的这个功能, 新加入了一个类型断言符号:as .<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = bar <span class="keyword">as</span> fool</span><br></pre></td></tr></table></figure></p><p>as操作符在.ts和.tsx里都可以用,并且与其他类型断言行为是等价的.</p><h2 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h2><p>为了理解JSX的类型检查,必须首先理解固有元素与基于值得元素之间的区别. 假设有这样一个JSX的表达式<expr>, expr可能引用环境自带的某些东西(比如, 在DOM环境的div或span)或者你自定义的组件. 这是非常重要的. 原因如下:</expr></p><ol><li>对于React, 固有元素会生成字符串(React.createElement(“div”)),然而又你自定义的组件却不会生成(React.createElement(MyComponent)) .</li><li>传入JSX元素里的属性类型的查找方式不同. 固有元素属性本身就支持, 然而自定义的组件会自己去指定它们具有哪个属性.</li></ol><p>TypeScript使用与<a href="http://facebook.github.io/react/docs/jsx-in-depth.html#html-tags-vs.-react-components" target="_blank" rel="noopener">React相同的规范</a>来区别它们. 固有元素总是以一个小写字母开头, 基于值得元素总是以一个大写字母开头.</p><h3 id="固有元素"><a href="#固有元素" class="headerlink" title="固有元素"></a>固有元素</h3><p>固有元素使用特殊的接口JSX.IntrinsicElements来查找. 默认地, 如果这个接口没有指定,会全部通过, 不对固有元素进行类型检查. 然而,如歌这个接口存在, 那么固有元素的名字需要在JSX.IntrinsicElements接口的属性里查找.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">declare namespace JSX &#123;</span><br><span class="line">    interface IntrinsicElements &#123;</span><br><span class="line">        foo:any</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;foo /&gt;; <span class="comment">//正确</span></span><br><span class="line">&lt;bar /&gt;; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure></p><p>在上例中,<foo>没有问题,但<bar>会报错, 因为它没有在JSX.IntrinsicElements里指定.</bar></foo></p><blockquote><p>注意: 也可以在JSXIntrinsicElements上指定一个用来捕获所有字符串索引:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">declare namespace JSX&#123;</span><br><span class="line">    interface IntrinsicELements &#123;</span><br><span class="line">        [elemName: string]: any;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="基于值的元素"><a href="#基于值的元素" class="headerlink" title="基于值的元素"></a>基于值的元素</h3><p>基于值得元素会简单的在它所在的作用域里按照标识符查找.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">'./myComponent'</span>;</span><br><span class="line"></span><br><span class="line">&lt;MyComponent /&gt;; <span class="comment">//correct</span></span><br><span class="line">&lt;SomeOtherComponent /&gt;; <span class="comment">//error</span></span><br></pre></td></tr></table></figure></p><p>可以限制基于值得元素的类型. 然而,为了这么做我们需要引入两个新的术语: 元素类的类型和元素实例的类型.</p><p>现在有<expr>, 元素类的类型为 Expr的类型. 所以上面的例子里, 如果 MyComponent 是ES6的类, name它的类类型就是这个类. 如果MyComponent是个工厂函数, 类类型为这个函数.</expr></p><p>一旦建立起了类类型, 实例类型就确定了, 为类类型调用签名的返回值与构造签名的联合类型. 再次说明, 在ES6类的情况下, 实例类类型为这个类的实例的类型,并且如果是工厂函数,实例类型为这个函数返回值类型.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> </span>&#123;</span><br><span class="line">    render()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用构造签名</span></span><br><span class="line"><span class="keyword">var</span> myComponent =<span class="keyword">new</span> MyComponent();</span><br><span class="line"></span><br><span class="line"><span class="comment">//元素类的类型 =&gt; MyComponent</span></span><br><span class="line"><span class="comment">//元素实例的类型 =&gt; &#123; render: ()=&gt;void&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFactoryFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        render:()=&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用调用签名</span></span><br><span class="line"><span class="keyword">var</span> myComponent = MyFactoryFunction();</span><br><span class="line"></span><br><span class="line"><span class="comment">//元素类的类型 =&gt; FactoryFunction</span></span><br><span class="line"><span class="comment">//元素实例的类型 =&gt; &#123;render: () =&gt; void&#125;</span></span><br></pre></td></tr></table></figure></p><p>元素的实例类型很有趣, 因为它必须赋值给JSX.ElementClass 或抛出一个错误. 默认的JSX.ElementClass为{}, 但是它可以被扩展用来限制JSX的类型以符合相应的接口.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">declare namespace JSX&#123;</span><br><span class="line">    interface ElementClass &#123;</span><br><span class="line">        render: any;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> </span>&#123;</span><br><span class="line">    render()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFactoryFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">render</span>:()=&#123;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;MyComponent /&gt; ; <span class="comment">//correct  </span></span><br><span class="line">&lt;MyFactoryFunction /&gt;; <span class="comment">//error</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotAvalidComponent</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NotAvalidFactoryFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;NotAvalidComponent /&gt;; <span class="comment">//corrent</span></span><br><span class="line">&lt;NotAvalidFactoryFunction /&gt;; <span class="comment">//error</span></span><br></pre></td></tr></table></figure></p><h3 id="属性类型检查"><a href="#属性类型检查" class="headerlink" title="属性类型检查"></a>属性类型检查</h3><p>属性类型检查的第一步是确定元素属性类型. 这在固有元素和基于值得元素之间稍有不同.</p><p>对于固有元素, 这是JSX.IntrinsicElements属性的类型.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">declare namespace JSX&#123;</span><br><span class="line">    interface IntrinsicElements &#123;</span><br><span class="line">        foo: &#123;bar?: boolean&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//foo 的元素类型为 &#123;bar? :boolean&#125;</span></span><br><span class="line">&lt;foo bar /&gt;</span><br></pre></td></tr></table></figure></p><p>对于基于值得元素, 就稍微复杂些. 它取决于先前确定的在元素实例类型上的某个属性的类型. 至于该使用哪个属性来确定类型取决于JSX.ElementAttributesProperty. 它应该使用单一的属性来确定. 这个属性名之后会被使用.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">declare namespace JSX &#123;</span><br><span class="line">    interface ElementAttributesProperty &#123;</span><br><span class="line">        props; <span class="comment">//指定用来使用的属性名.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在元素实例类型上指定属性</span></span><br><span class="line">    props: &#123;</span><br><span class="line">        foo? :string;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyComponent 的元素属性类型为 &#123;foo? : string&#125;</span></span><br><span class="line">&lt;MyComponent foo=<span class="string">"bar"</span>&gt;</span><br></pre></td></tr></table></figure></p><p>元素属性类型用于JSX里进行属性的类型检查. 支持可选属性和必选属性.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">declare namespace JSX &#123;</span><br><span class="line">    interface IntrinsicElements &#123;</span><br><span class="line">        foo: &#123;<span class="attr">requireedProp</span>: sting; </span><br><span class="line">        optionalProp? : number</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;foo requiredProp=<span class="string">"bar"</span> /&gt;; <span class="comment">//correct</span></span><br><span class="line">&lt;foo requiredProp=<span class="string">"bar"</span> optionalProp=&#123;<span class="number">0</span>&#125; /&gt;; <span class="comment">//correct</span></span><br><span class="line">&lt;foo /&gt;; <span class="comment">//error, lost requiredProp</span></span><br><span class="line">&lt;foo requiredProp=&#123;<span class="number">0</span>&#125; /&gt;; <span class="comment">//error the requiredProp should be string</span></span><br><span class="line">&lt;foo requiredPorp=<span class="string">"bar"</span> unknowProp /&gt;; <span class="comment">//error. the property of unknowProp does not exist</span></span><br><span class="line">&lt;foo requiredProp=<span class="string">"bar"</span> some-unknowm-prop /&gt;;  <span class="comment">//?????? correct, 'some-unknowm-prop' is not a 合法的标识符</span></span><br></pre></td></tr></table></figure></p><blockquote><p>注意点: 如果一个属性名不是合法的JS标识符(像data-*属性),并且它没出现艾元素属性类型里时不会当做一个错误.</p></blockquote><p>延展操作符也可以使用:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> props= &#123; <span class="attr">requiredProp</span>: <span class="string">"bar"</span>&#125;;</span><br><span class="line">&lt;foo &#123;...props&#125; /&gt;; <span class="comment">//correct</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> badProps=&#123;&#125;</span><br><span class="line">&lt;foo &#123;...badProps&#125; /&gt;; <span class="comment">//error</span></span><br></pre></td></tr></table></figure></p><h2 id="JSX结果类型"><a href="#JSX结果类型" class="headerlink" title="JSX结果类型"></a>JSX结果类型</h2><p>默认地, JSX表达式结果的类型为any. 你可以自定义这个类型, 通过制定 JSX.Element接口. 然而, 不能够从接口里检索元素, 属性或JSX的子元素的类型信息. 它是一个黑盒.</p><h2 id="嵌入的表达式"><a href="#嵌入的表达式" class="headerlink" title="嵌入的表达式"></a>嵌入的表达式</h2><p>JSX匀速你使用 {} 标签来内嵌表达式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a =<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;['foo','bar'].map(i=&gt;<span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;i/2&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>)&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>上面的代码产生一个错误, 因为你不能用数来来除以一个字符串, 输出如下<br>[ts] The left-hand side of an arithmetic operation must be of type ‘any’, ‘number’ or an enum type.</p><p>若你使用了preserve选项<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a =<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#123;['foo','bar'].map(function(i)&#123;return <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;i/3&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>;&#125;)&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><h2 id="React整合"><a href="#React整合" class="headerlink" title="React整合"></a>React整合</h2><p>要想一起使用JSX和React, 你应该使用<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react" target="_blank" rel="noopener">React类型定义</a>. 这些类型声明定义了JSX合适命名空间来使用React.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///&lt;reference path="react.d.ts" /&gt;</span></span><br><span class="line"></span><br><span class="line">interface Props &#123;</span><br><span class="line">    foo: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span>&lt;<span class="title">Props</span>,</span>&#123;&#125;&gt;&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;this.props.foo&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;MyComponent foo=<span class="string">"bar"</span>/&gt;; <span class="comment">//correct</span></span><br><span class="line">&lt;MyComoonent foo=&#123;<span class="number">0</span>&#125; /&gt;; <span class="comment">//error</span></span><br></pre></td></tr></table></figure></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a href="https://segmentfault.com/a/1190000009247663" target="_blank" rel="noopener">如何编写一个d.ts文件</a><br><a href="https://www.zhihu.com/question/52068257" target="_blank" rel="noopener">TypeScript 中的 .d.ts 文件有什么作用，这种文件的内如如何编写？</a></p><p>用 ts 写的模块在发布的时候仍然是用 js 发布，这就导致一个问题：ts 那么多类型数据都没了，所以需要一个 d.ts 文件来标记某个 js 库里面对象的类型<br>然后 typings 就是一个网络上的 d.ts 数据库</p><p>The End!</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;JSX是一种嵌入式的类似xml的语法. 它可以被转换成合法的JavaScript, 尽管转换的语义是根据不同的实现而定的. JSX因React框架而流行, 但是也被其他应用所使用. TypeScript支持内嵌,类型检核和将JSX直接便以为Javascript.&lt;/p&gt;
&lt;h2 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h2&gt;&lt;p&gt;使用JSX必须做两件事:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;给文件一个.tsx扩展名&lt;/li&gt;
&lt;li&gt;启用jsx选项&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="编程" scheme="https://xiaoxiaocoder.github.io/categories/programming/"/>
    
      <category term="javascript" scheme="https://xiaoxiaocoder.github.io/categories/programming/javascript/"/>
    
      <category term="typescript" scheme="https://xiaoxiaocoder.github.io/categories/programming/javascript/typescript/"/>
    
    
      <category term="typescript" scheme="https://xiaoxiaocoder.github.io/tags/typescript/"/>
    
      <category term="jsx" scheme="https://xiaoxiaocoder.github.io/tags/jsx/"/>
    
  </entry>
  
  <entry>
    <title>[TypeScript 15]手册指南: 声明组合</title>
    <link href="https://xiaoxiaocoder.github.io/programming/javascript/typescript/2017-08-23-typescript-15-declaration-merging.html"/>
    <id>https://xiaoxiaocoder.github.io/programming/javascript/typescript/2017-08-23-typescript-15-declaration-merging.html</id>
    <published>2017-08-23T13:48:19.000Z</published>
    <updated>2017-12-09T06:32:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>TypeScript中有些独特的概念可以在类型层面上描述Javascript对象的模型. 这其中尤其独特的一个例子是”声明合并”的概念. 理解了这个概念, 将有助于操作现有的Javascript代码. 同事, 也会有助于理解更多高级抽象的概念.</p><p>对于文件来讲, “声明合并”是指编译器将针对同一个名字的两个独立声明本病为单一声明. 合并后的声明同事拥有原先两个声明的特性. 任何数量的声明都可被合并; 不局限于两个声明.</p><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>TypeScript中的声明会创建以下的三中实体之一: 命名空间,类或值. 创建命名空阿金的声明会新建一个命名空间,它包含了用(.) 符号来访问时使用的名字. 创建类型的声明时:用声明的模型创建一个类型并绑定到给定的名字上. 最后,创建值得声明会创建在Javascript输出中看到的值.<br><a id="more"></a></p><table><thead><tr><th>Declaration Type</th><th>Namespace</th><th>Type</th><th>Value</th></tr></thead><tbody><tr><td>Namespace</td><td>X</td><td></td><td>X</td></tr><tr><td>Class</td><td></td><td>X</td><td>x</td></tr><tr><td>Enum</td><td></td><td>X</td><td>x</td></tr><tr><td>Interface</td><td></td><td>X</td><td></td></tr><tr><td>Type Alias</td><td></td><td>X</td><td></td></tr><tr><td>Function</td><td></td><td></td><td>X</td></tr><tr><td>Variable</td><td></td><td></td><td>X</td></tr></tbody></table><p>理解每个声明创建了什么, 有助于理解当声明合并时有哪些东西被合并了.</p><h3 id="合并接口"><a href="#合并接口" class="headerlink" title="合并接口"></a>合并接口</h3><p>最简单也是最常见的声明合并类型是接口合并, 从根本上说, 合并的机制是把双方的成员放到一个同名的接口里.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface Box&#123;</span><br><span class="line">    height:number;</span><br><span class="line">    widht:number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Box&#123;</span><br><span class="line">    scale: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> box:Box =&#123;<span class="attr">height</span>:<span class="number">5</span>,<span class="attr">width</span>:<span class="number">6</span>, <span class="attr">scale</span>:<span class="number">30</span>&#125;</span><br></pre></td></tr></table></figure></p><p>接口的非函数的长远必须是唯一的. 如果两个接口中同事声明了非函数成员编译器会报错.</p><p>对于函数成员, 每个同名函数声明都会被当做这个函数的一个重载. 同事需要注意,当接口A与后来的接口A合并时,后面的接口具有更高的优先级.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">interface Cloner&#123;</span><br><span class="line">    clone(animal: Animal):Animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Cloner&#123;</span><br><span class="line">    clone(animal:Animal): Sheep;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Cloner(</span><br><span class="line">    clone(animal:Dog) :Dog;</span><br><span class="line">    clone(animal:Cat): Cat;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//这三个接口合并成一个声明</span></span><br><span class="line">interface Cloner&#123;</span><br><span class="line">    clone(animal:Dog):Dog;</span><br><span class="line">    clone(animal:Cat):Cat;</span><br><span class="line">    clone(animal:Sheep):Sheep;</span><br><span class="line">    clone(animal:Animal):Animal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意每组接口里的声明顺序保持不变, 但各组接口之间的顺序是后来的接口重载出现的靠前的位置.</p><p>这个规则有一个例外是当出现特殊的函数签名时. 如果签名里有一个参数的类型是单一的字符串字面量(如,不是字符串字面量的联合类型),那么它将会被提升到重载列表的最顶端<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">interface Document&#123;</span><br><span class="line">    createElement(tagName: any): Element;</span><br><span class="line">&#125;</span><br><span class="line">interface Document&#123;</span><br><span class="line">    createElement(tagName: <span class="string">"div"</span>): HTMLDivElement;</span><br><span class="line">    createElement(tagName:<span class="string">"span"</span>): HTMLSpanElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Document&#123;</span><br><span class="line">    createElement(tagName: string): HTMLElement;</span><br><span class="line">    createElement(tagName:<span class="string">"canvas"</span>): HTMLCanvasElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并后的Document:</span></span><br><span class="line">interface Document&#123;</span><br><span class="line">    createElement(tagName:<span class="string">"canvas"</span>): HTMLCanvasElement;</span><br><span class="line">    createElement(tagName:<span class="string">"div"</span>): HTMLDivElement;</span><br><span class="line">    createElement(tagName:<span class="string">"span"</span>):HTMLSpanElement;</span><br><span class="line">    createElement(tagName: string: HTMLElement;</span><br><span class="line">    createElement(tagName:any):Element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="合并命名空间"><a href="#合并命名空间" class="headerlink" title="合并命名空间"></a>合并命名空间</h2><p>与接口相似, 同名的命名空间也会合并其他成员. 命名空间也创建出命名空间和值, 我们需要知道这两者都是怎么合并的.<br>对于命名空间的合并,模块导出的同名接口进行合并,构成单一命名空间内含合并后的接口.</p><p>对于命名空间里值得合并,如果当前已经存在给定名字的命名空间,name后来IDE命名空间的导出成员会被加到已经存在额那个模块里.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">namespace Animals&#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Zebra</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace Animals&#123;</span><br><span class="line">    <span class="keyword">export</span> interface Legged &#123; <span class="attr">numberOfLegs</span>: number;&#125;</span><br><span class="line">    <span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并后</span></span><br><span class="line">namespace Animals&#123;</span><br><span class="line">    <span class="keyword">export</span> interface Legged &#123; <span class="attr">numberOfLegs</span>: number&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Zebra</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了这些合并外,你还需要了解非导出成员是如何处理的. 非导出成员仅在其原有的(合并前的)命名空间内可见. 这就是说合并之后,从其他命名空间合并进来的成员无法访问非导出成员.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">namespace Animal &#123;</span><br><span class="line">    <span class="keyword">let</span> haveMuscles =<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">animalsHavaMuscles</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> haveMUscles;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace Animal&#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">doAnimalHaveMuscles</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> haveMuscles; <span class="comment">// error, haveMuscles is not visible here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为haveMuscles并没有导出,只有animalsHaveMuscles函数共享了原始末合并的命名空间可以访问这个变量. doAnimalHaveMuscles函数虽然是合并命名空间的一部分,但是访问不了未导出的成员.</p><h2 id="命名空间与类和函数和枚举类型合并"><a href="#命名空间与类和函数和枚举类型合并" class="headerlink" title="命名空间与类和函数和枚举类型合并"></a>命名空间与类和函数和枚举类型合并</h2><p>命名空间可以与其他类型的声明进行合并. 只要命名空间的定衣服和将要合并类型的定义. 合并结果包含两者的声明类型. TypeScript 使用这个功能区实现一些JavaScript里的设计模式.</p><h3 id="合并命名空间和类"><a href="#合并命名空间和类" class="headerlink" title="合并命名空间和类"></a>合并命名空间和类</h3><p>这让我们可以表示内部类<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Album</span></span>&#123;</span><br><span class="line">    label: Album.AlbumLabel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace Album&#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AlbumLabel</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>命名规则与上面<strong>合并命名空间</strong>小节里将的规则一致,我们必须导出AlbumLabel类,好让合并的类能够访问. 合并结果是一个类并带有一个内部类. 你也可以使用命名空间为类增加一些静态属性.</p><p>除了内部类的模式,你在Javascript里,创建一个函数稍后扩展它增加一些属性也是很常见的. TypeScript使用声明合并来达到这个目的并保证类型安全.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildLabel</span>(<span class="params">name:string</span>):<span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> buildLabel.prefix +name +buildLabel.suffix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace buildLabel &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">let</span> suffix=<span class="string">""</span>;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">let</span> prefix=<span class="string">"hello,"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(buildLabel(<span class="string">"same simth"</span>))</span><br></pre></td></tr></table></figure></p><p>相似的, 命名空间可以用来扩展枚举类型:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">enum Color&#123;</span><br><span class="line">    red=<span class="number">1</span>,</span><br><span class="line">    green=<span class="number">2</span>,</span><br><span class="line">    blue=<span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace Color&#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mixColor</span>(<span class="params">colorName: string</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(colorName==<span class="string">"yellow"</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Color.red + Color.green;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(colorName ==<span class="string">"white"</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Color.red +Color.green +Color.blue;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(colorName ==<span class="string">"magenta"</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Color.red+Color.blue;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(colorName ==<span class="string">"cyan"</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Color.green +Color.blue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="非法的合并"><a href="#非法的合并" class="headerlink" title="非法的合并"></a>非法的合并</h2><p>TypeScript并非允许所有的合并. 目前, 类不能与其他类或者变量合并, 想要了解如何模仿类的合并, 参考<a href="https://www.tslang.cn/docs/handbook/mixins.html" target="_blank" rel="noopener">TypeScript混入</a></p><h2 id="模块扩展"><a href="#模块扩展" class="headerlink" title="模块扩展"></a>模块扩展</h2><p>虽然JavaScript不支持合并,但你可以为导入的对象打补丁以更新它们.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//observable.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//... implementation left as an exercise for the reader...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//map.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; Observable &#125; <span class="keyword">from</span> <span class="string">"./observable"</span>;</span><br><span class="line">Observable.prototype.map=<span class="function"><span class="keyword">function</span>(<span class="params">f</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//... another exercise for the reader</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它可以很好的工作在TypeScript中,但编译器对Observable.prototype.map一无所知. 可以使用扩展模块来告诉编译器.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//observable.ts stays the same</span></span><br><span class="line"><span class="comment">//map.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Observable &#125; <span class="keyword">from</span> <span class="string">"./observable"</span>;</span><br><span class="line">declare <span class="built_in">module</span> <span class="string">"./observable"</span> &#123;</span><br><span class="line">    interface Observable&lt;T&gt;&#123;</span><br><span class="line">        map&lt;U&gt;<span class="function">(<span class="params">f:(x:T</span>)=&gt;</span>U): Observable&lt;U&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Observable.prototype.map=<span class="function"><span class="keyword">function</span>(<span class="params">f</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//another exercise for the reader</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//consumer.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Observable &#125; <span class="keyword">from</span> <span class="string">"./observable"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"./map"</span></span><br><span class="line"><span class="keyword">let</span> o: Observable&lt;number&gt;;</span><br><span class="line">o.map(<span class="function"><span class="params">x</span>=&gt;</span>x.toFixed());</span><br></pre></td></tr></table></figure></p><p>模块名解析和用import/export解析模块标识符的方式是一致的. 更多信息参考<a href="https://www.tslang.cn/docs/handbook/modules.html" target="_blank" rel="noopener">Modules</a>. 当这些声明在扩展中合并时, 就好像在原始位置被声明了一样. 但是, 你不能再扩展中新的顶级声明 - 仅可以扩展模块中已经存在的声明.</p><h2 id="全局扩展"><a href="#全局扩展" class="headerlink" title="全局扩展"></a>全局扩展</h2><p>你也可以在模块内部添加声明到全局作用域中.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//observable.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//.. still no implementation</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare global &#123;</span><br><span class="line">    interface <span class="built_in">Array</span>&lt;T&gt;&#123;</span><br><span class="line">        toObservable(): Observable&lt;T&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.toObservable=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>全局扩展与模块扩展的行为和显示是相同的.</p><p>The End!</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;TypeScript中有些独特的概念可以在类型层面上描述Javascript对象的模型. 这其中尤其独特的一个例子是”声明合并”的概念. 理解了这个概念, 将有助于操作现有的Javascript代码. 同事, 也会有助于理解更多高级抽象的概念.&lt;/p&gt;
&lt;p&gt;对于文件来讲, “声明合并”是指编译器将针对同一个名字的两个独立声明本病为单一声明. 合并后的声明同事拥有原先两个声明的特性. 任何数量的声明都可被合并; 不局限于两个声明.&lt;/p&gt;
&lt;h2 id=&quot;基础概念&quot;&gt;&lt;a href=&quot;#基础概念&quot; class=&quot;headerlink&quot; title=&quot;基础概念&quot;&gt;&lt;/a&gt;基础概念&lt;/h2&gt;&lt;p&gt;TypeScript中的声明会创建以下的三中实体之一: 命名空间,类或值. 创建命名空阿金的声明会新建一个命名空间,它包含了用(.) 符号来访问时使用的名字. 创建类型的声明时:用声明的模型创建一个类型并绑定到给定的名字上. 最后,创建值得声明会创建在Javascript输出中看到的值.&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://xiaoxiaocoder.github.io/categories/programming/"/>
    
      <category term="javascript" scheme="https://xiaoxiaocoder.github.io/categories/programming/javascript/"/>
    
      <category term="typescript" scheme="https://xiaoxiaocoder.github.io/categories/programming/javascript/typescript/"/>
    
    
      <category term="typescript" scheme="https://xiaoxiaocoder.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>[TypeScript 14]手册指南: 模块解析</title>
    <link href="https://xiaoxiaocoder.github.io/programming/javascript/typescript/2017-08-22-typescript-14-module-resolution.html"/>
    <id>https://xiaoxiaocoder.github.io/programming/javascript/typescript/2017-08-22-typescript-14-module-resolution.html</id>
    <published>2017-08-22T07:16:10.000Z</published>
    <updated>2017-12-09T06:32:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>模块解析就是指编译器所要一句的一个流程, 用它来找出某个导入操作所引用额具体值. 假设有一个导入语句 import {a} from ‘moduleA’; 为了去检查任何对a的使用,编译器需要准确的知道它表示什么,并且会需要检查他的定义moduleA.</p><p>这时, 编译器会想知道”moduleA的shape是怎样的?” 这听上去很简单, moduleA可能在你写的某个 .ts/.tsx文件里或者在你的代码所依赖的.d.ts里.</p><a id="more"></a><p>首先, 编译器会尝试定位表示导入模块的文件. 编译会遵循下列二种策略之一: Classic 或 Node. 这些策略会告诉编译器到哪里去查找moduleA.</p><p>如果他们失败了并且如果模块名是非相对的(且是在”moduleA”的情况下), 编译器会尝试定位一个外部模块声明. 接下来胡降到非相对导入.</p><p>最后, 如果编译器还是不能解析这个模块, 他会记录一个错误. 在这种情况下,错误可能未 error TS2307: Cannot find modle ‘moduleA’</p><h2 id="相对vs-非相对模块导入"><a href="#相对vs-非相对模块导入" class="headerlink" title="相对vs. 非相对模块导入"></a>相对vs. 非相对模块导入</h2><p>根据模块引用是相对的还是非相对的,模块导入会以不同的方式解析.</p><p>根据导入是以/,./或../开头的.</p><ul><li>import Entry from “./components/Entry”;</li><li>import { DefaultHeaders } from “../constants/http”</li><li>import “/mod”</li></ul><p>所有其他形式的导入被当做非相对的. 下面的例子:</p><ul><li>import * as $ from “jQuery”;</li><li>import { Component } from “@angular/core”;<br>相对导入解析时时相对于导入它的文件夹来的. 并且不能解析为一个外部模块声明. 你应该为你自己写的模块使用相对导入, 这样能确保它们在运行时的相对位置.</li></ul><p>非相对模块的导入可以相对于baseUrl 或通过下文会降到的路径映射来进行解析. 它们还可以被解析能外部模块声明. 使用非相对路径来导入你的外部依赖.</p><h2 id="模块解析策略"><a href="#模块解析策略" class="headerlink" title="模块解析策略"></a>模块解析策略</h2><p>共有两种可用的模块解析策略: <a href="https://www.tslang.cn/docs/handbook/module-resolution.html#node" target="_blank" rel="noopener">Node</a> 和 <a href="https://www.tslang.cn/docs/handbook/module-resolution.html#classic" target="_blank" rel="noopener">classic</a>. 你可以使用 –moduleResolution 标记指定使用哪种模块解析策略. 若为指定, name在使用了 –module AMD | System | ES2015时的默认值为Classic,其他情况时则为Node.</p><h3 id="Classic"><a href="#Classic" class="headerlink" title="Classic"></a>Classic</h3><p>这种策略以前是TypeScript默认的解析策略. 现在,它存在的理由主要是为了向后兼容.</p><p>相对导入的模块是相对于导入它的文件进行解析的. 因此/root/src/folder/A.ts文件里的import {b} from “./moduleB” 会只用下面的查找流程</p><ol><li>/root/src/folder/moduleB.ts</li><li>/root/src/folder/moduleB.d.ts</li></ol><p>对非相对模块的导入,编译器会从包含导入文件的目录开始依次向上级目录遍历,尝试定位匹配的声明文件. 如:<br>有一个对moduleB的非相对导入 import {b} from “moduleB”, 它是在/root/src/folder/A.ts文件里, 会以如下的方式定位”moduleB”:</p><ol><li>/root/src/folder/moduleB.ts</li><li>/root/src/folder/moduleB.d.ts</li><li>/root/src/moduleB.ts</li><li>/root/src/moduleB.d.ts</li><li>/root/moduleB.ts</li><li>/root/moduleB.d.ts</li><li>/moduleB.ts</li><li>/moduleB.d.ts</li></ol><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>这个解析策略驶入在运行时模仿Node.js模块解析机制. 完整的Node.js解析算法可以在Node.js module documentation中找到.</p><p><strong>Node.js如何解析模块</strong><br>通常, 在Node.js里导入是通过require函数调用进行的. Node.js会根据require是相对路径还是非相对路径做出不同的行为.</p><ul><li>相对路径. 例,假设有一个文件路径名为 /root/src/moduleA.js,包含了一个导入 var x= require(“./moduleB”); Node.js以下面的顺序解析这个导入:</li></ul><ol><li>将/root/src/moduleB.js视为文件,检查是否存在.</li><li>将/root/src/moduleB视为目录,检查是否它包含package.json文件并且其指定了一个main模块. 该例中, 如果Node.js发现文件/root/src/moduleB/package.json包含了 {“main”: “lib/mainModule.js”},那么Node.js会引用/root/src/moduleB/lib/mainModule.js</li><li>将/root/src/moduleB视为目录,检查它是否包含index.js文件. 这个文件会被隐式地当做那个文件夹下的main模块.</li></ol><p>可以阅读Node.js文档了解更多详细信息: <a href="https://nodejs.org/api/modules.html#modules_file_modules" target="_blank" rel="noopener">file modules</a> 和 <a href="https://nodejs.org/api/modules.html#modules_folders_as_modules" target="_blank" rel="noopener">folder modules</a></p><p>但是,非相对模块名的解析是完全不同的过程. Node会在一个特殊的文件夹node_modules里查找你的模块. node_modules可能与当前文件在同一级目录,或者在上层目录里. Node会向上级目录遍历,查找每个node_modules 知道它找到要加载的模块.</p><p>上面的例子, 但假设 /root/src/moduleA.js 里使用的是费相对路径导入 var x= require(“moduleB”); Node则会以下面的顺序去解析moduleB. 知道有一个匹配上.</p><ol><li>/root/src/node_modules/moduleB.js</li><li>/root/src/node_modules/moduleB/package.json (如果制定了main属性)</li><li>/root/src/node_modules/moduleB/index.js</li><li>/root/node_modules/moduleB.js</li><li>/root/node_modules/moduleB/package.json (如果指定了main属性)</li><li>/root/node_modules/moduleB/index.js</li><li>/node_modules/moduleB.js</li><li>/node_modules/moduleB/package.json (如果指定了main属性)</li><li>/node_modules/moduleB/index.js<br>注意Node.js在步骤4,7会向上跳一级目录. <a href="https://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders" target="_blank" rel="noopener">loading modules from node_modules</a></li></ol><h3 id="TypeScript如何解析模块"><a href="#TypeScript如何解析模块" class="headerlink" title="TypeScript如何解析模块"></a>TypeScript如何解析模块</h3><p>TypeScript是模仿Node.js运行时的解析策略来在编译阶段定位模块定义文件. 因此, TypeScript在Node解析逻辑基础上增加了TypeScript源文件的扩展名(.ts,.tsx和.d.ts). 同事,TypeScript在package.json里使用typings来表示类似main的意义. 编译器会使用它来找到使用main定义文件.</p><p>比如, 有一个导入语句 import {b} from “./moduleB” 在 /root/src/moduleA.ts里, 会以下的流程来定位”./moduleB”</p><ol><li>/root/src/moduleB.ts</li><li>/root/src/moduleB.tsx</li><li>/root/src/moduleB.d.ts</li><li>/root/src/moduleB/package.json (如果指定typings属性)</li><li>/root/src/moduleB/index.ts</li><li>/root/src/moduleB/index.tsx</li><li>/root/src/moduleB/index.d.ts</li></ol><p>回想一下Node.js县查找moduleB.js,然后是合适的package.json,再之后是index.js</p><p>类似地, 非相对的导入会遵循Node.js的解析逻辑,首先查找文件,然后是合适的文件夹. 因此/root/src/moduleA.ts 文件里的import {b} from “moduleB” 会以下面的查找顺序解析:</p><ol><li>/root/src/node_modules/moduleB.ts</li><li>/root/src/node_modules/moduleB.tsx</li><li>/root/src/node_modules/moduleB.d.ts</li><li>/root/src/node_modules/moduleB/package.json (如果制定了typing属性)</li><li>/root/src/node_modules/moduleB/index.ts</li><li>/root/src/node_modules/moduleB/index.tsx</li><li>/root/src/node_modules/moduleB/index.d.ts</li><li>/root/node_modules/moduleB.ts</li><li>/root/node_modules/moduleB.tsx</li><li>/root/node_modules/moduleB.d.ts</li><li>/root/node_modules/moduleB/package.json (如果制定了typing属性)</li><li>/root/node_modules/moduleB/index.ts</li><li>/root/node_modules/moduleB/index.tsx</li><li>/root/node_modules/moduleB/index.d.ts</li><li>/node_modules/moduleB.ts</li><li>/node_modules/moduleB.tsx</li><li>/node_modules/moduleB.d.ts</li><li>/node_modules/moduleB/package.json (如果制定了typing属性)</li><li>/node_modules/moduleB/index.ts</li><li>/node_modules/moduleB/index.tsx</li><li>/node_modules/moduleB/index.d.ts<br>8,15向上跳了两次目录</li></ol><h2 id="附加的模块解析标记"><a href="#附加的模块解析标记" class="headerlink" title="附加的模块解析标记"></a>附加的模块解析标记</h2><p>有时候工程源码结果与输出解构不同. 通常是要经过一系统的构建步骤最后生成输出. 它们包括将.ts编译成.js ,将不同位置的依赖拷贝至一个输出位置. 最终结果就是运行时的模块名与包含它们声明的源文件里的模块名不同. 或者最终输出文件里的模块路径与编译时的源文件路径不同了.</p><p>TypeScript编译器有一些额外的标记用来通知编译器在源码编译成最终输出的过程中都发生了哪个转换.</p><p>有一点要特别注意的是编译器不会进行这些转换操作; 它只是利用这些信息来知道模块的导入.</p><p><em>Base URL</em><br>在利用AMD模块加载的应用里使用baseUrl时常见做法, 它要求在运行时模块都被放到一个文件夹里. 这些模块的源码可以在不同的目录下,但是构建脚本会将它们集中到一起.</p><p>设置baseUrl来告诉编译器到哪里去查找模块. 所有非相对模块导入都会被当做相对于baseUrl .</p><p>baseUrl的值由以下两者之一决定:</p><ul><li>命令行中baseUrl的值 (如果给定的路径是相对的,name将相对于当前路径进行计算)</li><li>‘tsconfig.json’里的baseUrl属性(如果给定的路径是相对的,那么将相对于’tsconfig.json’路径进行计算)</li></ul><p>注意相对模块的导入不会被设置的baseUrl所影响,因为它们总是相对于导入它们的文件.</p><p>阅读更多关于<a href="">baseUrl</a>的信息<a href="http://requirejs.org/docs/api.html#config-baseUrl" target="_blank" rel="noopener">RequireJS</a> 和<a href="https://github.com/systemjs/systemjs/blob/master/docs/config-api.md#baseurl" target="_blank" rel="noopener">SystemJS</a></p><h3 id="路径映射"><a href="#路径映射" class="headerlink" title="路径映射"></a>路径映射</h3><p>有时模块不是直接放在baseUrl下面. 比如, 充分”jquery”模块地导入, 在运行时可能被解析为”node_modules/jquery/dist/jquery.slim.min.js”. 加载器使用映射配置来讲模块名映射到运行时的文件. 查看 <a href="http://requirejs.org/docs/api.html#config-paths" target="_blank" rel="noopener">Requirejs documentation</a> 和 <a href="https://github.com/systemjs/systemjs/blob/master/docs/config-api.md#paths" target="_blank" rel="noopener">SystemJS documentation</a></p><p>TypeScript编译器通过使用tsconfig.js文件里的”paths”来支持这样的声明映射.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"complierOptions"</span>:&#123;</span><br><span class="line">        <span class="string">"baseUrl"</span>: <span class="string">"."</span>, <span class="comment">// This must be specified if "paths" is.</span></span><br><span class="line">        <span class="string">"paths"</span>:&#123;</span><br><span class="line">            <span class="string">"jquery"</span>:[<span class="string">"node_modules/jquery/dist/jquery"</span>] <span class="comment">//此处映射是相对于"baseUrl"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>“paths”是相对于”baseUrl”进行解析. 如果”baseUrl”被设置成了除”.”外的其他值, 比如 tsconfig.json所在的目录,name映射必须要做的相应的改变. 如果你在上例中设置了”baseUrl”:”./src”, namejquery映射映射到”../node_modules/jquery/dist/jquery”.</p><p>通过”paths” 我们还可以指定复杂的映射,包括指定多个回退位置. 假设在一个工程配置里, 有一些模块位于一处,而其他的则在另个的位置.构建过程会将它们集中至一处. 工程结果如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">projectRoot</span><br><span class="line">    folder1</span><br><span class="line">        file1.ts (<span class="keyword">import</span> <span class="string">"folder1/file2"</span> and <span class="string">'folder2/file3'</span>)</span><br><span class="line">        file2.ts</span><br><span class="line">    generated</span><br><span class="line">        folder1</span><br><span class="line">        folder2</span><br><span class="line">            file3.ts</span><br><span class="line">    tsconfig.json</span><br></pre></td></tr></table></figure></p><p>相应的tsconfig.json文件如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"compilerOptions"</span>:&#123;</span><br><span class="line">        <span class="string">"baseUrl"</span>:<span class="string">"."</span>,</span><br><span class="line">        <span class="string">"paths"</span>:&#123;</span><br><span class="line">            <span class="string">"*"</span>:[<span class="string">"*"</span>,<span class="string">"generated/*"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它告诉编译器所有匹配”*”(所有的值)模式的模块导入会在以下两个位置查找:</p><ol><li>“*”: 表示名字不发生改变,所以映射为<modulename>=&gt; <baseurl>/<modulename></modulename></baseurl></modulename></li><li>“generated/*”表示模块添加了”generated”前缀,所以映射为<modulename>=&gt;<baseurl>/generated/<modulename></modulename></baseurl></modulename></li></ol><p>按照这个逻辑,编译器将会尝试解析这两个导入:</p><ul><li>导入’folder1/file2’<pre><code>1. 匹配&quot;*&quot;模式且通配符捕获到整个名字.2. 尝试列表里额第一个替换: &quot;*&quot; -&gt; folder1/file23. 替换结果为非相对名 -与 baseUrl合并 -&gt; projectRoot/ folder1/file2.ts4. 文件存在. 完成</code></pre></li><li>导入’folder2/file3’<pre><code>1. 匹配&quot;*&quot;模式且通配符捕获到整个名字.2. 尝试列表里的第一个替换: &quot;*&quot; -&gt; folder2/file33. 替换结果为非相对名 - 与baseUrl 合并 -&gt; projectRoot/folder2/file3.ts4. 文件不存在,跳到第二个替换5. 第二个替换: &apos;generated/*&apos; -&gt; generated/folder2/file36. 替换结果为非相对名 - 与baseUrl合并 -&gt; projectRoot/generated/folder2/file3.ts7. 文件存在, 完成.</code></pre></li></ul><h2 id="利用rootDirs指定虚拟目录"><a href="#利用rootDirs指定虚拟目录" class="headerlink" title="利用rootDirs指定虚拟目录"></a>利用rootDirs指定虚拟目录</h2><p>有时多个目录下的工程源文件在编译时会进行合并放在某个输出目录下. 这可以看做一些源目录创建了一个”虚拟”目录.</p><p>利用rootDirs, 可以告诉编译器生成这个虚拟目录的roots; 因此编译器可以在虚拟目录下解析先对模块导入, 就好像他们被合并在一起一样.</p><p>如, 下面的工程结构:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">    views</span><br><span class="line">        view1.ts    (<span class="keyword">import</span> <span class="string">'./template1'</span>)</span><br><span class="line">        view2.ts</span><br><span class="line">generated</span><br><span class="line">    templates</span><br><span class="line">        views</span><br><span class="line">            template1.ts (<span class="keyword">import</span> <span class="string">'./view2'</span>)</span><br></pre></td></tr></table></figure></p><p>src/views 里的文件时用于控制UI的用户代码. generated/templates是UI模块. 在构建时通过模块生成器自动生成. 构建中的一步讲 /src/views 和 /generated/templates/views 的输出目录拷贝到同一目录下. 在运行时, 视图可以假设它的模板与它同在一个目录下,因此可以使用相对导入 “./template1”</p><p>可以使用”rootDirs”来告诉编译器. “rootDirs”指定了一个roots列表,列表里的内容会在运行时被合并. 因此,针对这个例子, tsconfig.json如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"compilerOptions"</span>:&#123;</span><br><span class="line">        <span class="string">"rootDirs"</span>:[<span class="string">"src/views"</span>,<span class="string">"generated/templates/views"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每当编译器在某一rootDirs的子目录下发现了相对模块导入,它就会尝试从每一个rootDirs中导入.</p><p>rootDirs的灵活性不仅仅局限于其指定了要在逻辑上合并的物理目录列表,它提供了数组可以包含任意数量的任何名字的目录,不论它们是存在. 这允许编译器以类型安全的方式处理复杂捆绑(bundles)和运行时的特性, 比如条件引入和工程特定的加载器插件.</p><p>设想这样一个国际化的场景, 构建工具自动插入特定的路径记号来生成针对不同区域的捆绑, 比如将#{locale}作为相对模块路径. ./#{locale}/messages的一部分. 在这个假定的设置下,工具会枚举支持的区域,将抽象的路径映射成./zh/messages,./de/messages等.</p><p>假设每个模块都会导出一个字符串的数组. 比如 ./zh/messages可能包含:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [</span><br><span class="line">    <span class="string">"hello"</span>,</span><br><span class="line">    <span class="string">"nice to meet you"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>利用rootDirs我们可以让编译器了解这个映射关系,从而也允许编译器能够安全地解析./#{locale}/messages,就算这个目录永远都不存在. 比如, 使用下面的tsconfig.json:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"compilerOptions"</span>:&#123;</span><br><span class="line">        <span class="string">"rootDirs"</span>:[</span><br><span class="line">            <span class="string">"src/zh"</span>,</span><br><span class="line">            <span class="string">"src/de"</span>,</span><br><span class="line">            <span class="string">"src/#&#123;locale&#125;"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译器现在可以将 import messages from ‘./#{locale}/messages’ 解析为 import messages from ‘./zh/messages’ 用做工具支持的目的. 并允许在开发时不必了解区域信息.</p><h2 id="跟踪模块解析"><a href="#跟踪模块解析" class="headerlink" title="跟踪模块解析"></a>跟踪模块解析</h2><p>编译器在解析模块时可能范文当前文件夹外的文件. 这会导致很难诊断模块为什么没有被解析,或者解析到了错误的位置. 通过 –traceResolution启动编译器的模块解析跟踪, 它会告诉我们在模块解析过程中发生了什么.</p><p>假设我们有一个使用了TypeScript模块的简单应用. app.ts里有一个这样的导入 import * as ts from “typescript”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tsconfig.json</span><br><span class="line">node_modules</span><br><span class="line">    typescript</span><br><span class="line">        lib</span><br><span class="line">            typescript.d.ts</span><br><span class="line">src</span><br><span class="line">    app.ts</span><br></pre></td></tr></table></figure></p><p>使用–traceResolution调用编译器<br><code>tsc --traceResolution</code><br>输出结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">======== Resolving module &apos;typescript&apos; from &apos;src/app.ts&apos;. ========</span><br><span class="line">Module resolution kind is not specified, using &apos;NodeJs&apos;.</span><br><span class="line">Loading module &apos;typescript&apos; from &apos;node_modules&apos; folder.</span><br><span class="line">File &apos;src/node_modules/typescript.ts&apos; does not exist.</span><br><span class="line">File &apos;src/node_modules/typescript.tsx&apos; does not exist.</span><br><span class="line">File &apos;src/node_modules/typescript.d.ts&apos; does not exist.</span><br><span class="line">File &apos;src/node_modules/typescript/package.json&apos; does not exist.</span><br><span class="line">File &apos;node_modules/typescript.ts&apos; does not exist.</span><br><span class="line">File &apos;node_modules/typescript.tsx&apos; does not exist.</span><br><span class="line">File &apos;node_modules/typescript.d.ts&apos; does not exist.</span><br><span class="line">Found &apos;package.json&apos; at &apos;node_modules/typescript/package.json&apos;.</span><br><span class="line">&apos;package.json&apos; has &apos;typings&apos; field &apos;./lib/typescript.d.ts&apos; that references &apos;node_modules/typescript/lib/typescript.d.ts&apos;.</span><br><span class="line">File &apos;node_modules/typescript/lib/typescript.d.ts&apos; exist - use it as a module resolution result.</span><br><span class="line">======== Module name &apos;typescript&apos; was successfully resolved to &apos;node_modules/typescript/lib/typescript.d.ts&apos;. ========</span><br></pre></td></tr></table></figure></p><h3 id="需要留意的地方"><a href="#需要留意的地方" class="headerlink" title="需要留意的地方"></a>需要留意的地方</h3><ul><li>导入的名字及位置<blockquote><p>  ========Resolving module ‘typescript’ from ‘src/app.ts’=======</p></blockquote></li><li>编译器使用策略<blockquote><p>  Module resolution kind is not specified, using ‘NodeJs’</p></blockquote></li><li>从npm加载typings<blockquote><p>  ‘package.json’ has ‘typings’ field ‘./lib/typescript.d.ts’ has references ‘node_modules/typescript/lib/typescript.d.ts’</p></blockquote></li><li>最终结果<blockquote><p>  =======Module name ‘typescript’ was successfully resolved to ‘node_modules/typescript/lib/typescript.d.ts’======</p></blockquote></li></ul><h2 id="使用-–noResolve"><a href="#使用-–noResolve" class="headerlink" title="使用 –noResolve"></a>使用 –noResolve</h2><p>正常来讲编译器会在开始编译器之前解析模块导入. 每当它成功解析对一个文件import,这个文件被会加到一个文件列表里,以便编译器稍后处理.</p><p>–noResolve编译选项告诉编译器不要添加任何不适在命令行上传入的文件到编译列表. 编译器仍然会尝试解析模块,但是只要没有指定这个文件,那么它就不会被包含在内.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//app.ts</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> A <span class="keyword">from</span> <span class="string">"moduleA"</span> <span class="comment">//Ok, moduleA passed on the command-line</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> B <span class="keyword">from</span> <span class="string">"moduleB"</span> <span class="comment">//error ts2307: cannot find module 'moduleB'.</span></span><br><span class="line"></span><br><span class="line">tsc app.ts moduleA.ts --noResolve</span><br></pre></td></tr></table></figure></p><p>使用–noResolve编译app.ts:</p><ul><li>可能正确找到moduleA,因为它在命令行上指定了.</li><li>找不到moduleB,因为没有在命令行上传递.</li></ul><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="为什么在exclude列表了的模块还会被编译器使用"><a href="#为什么在exclude列表了的模块还会被编译器使用" class="headerlink" title="为什么在exclude列表了的模块还会被编译器使用"></a>为什么在exclude列表了的模块还会被编译器使用</h3><p>tsconfig.json 将文件夹转变一个”工程”如果不指定任何”exclude”或”files”, 文件夹里的所有文件包括tsconfig.json和所有的子目录都会在编译器列表. 如果你想利用”exclude”排除某些文件,甚至你想指定所有要编译的文件列表,请使用”files”.</p><p>有些是被tsconfig.json自动加入的. 它不会涉及到上面讨论的模块解析. 如果编译器识别出一个文件是模块导入目标, 它就会加到编译列表里, 不管它是否被排除了.</p><p>因此,要从编译列表中排除一个文件, 你需要在排除它的同时, 还要排除所有对它进行 import 或使用了///<reference path="..."> 指令的文件.</reference></p><p>The End! </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;模块解析就是指编译器所要一句的一个流程, 用它来找出某个导入操作所引用额具体值. 假设有一个导入语句 import {a} from ‘moduleA’; 为了去检查任何对a的使用,编译器需要准确的知道它表示什么,并且会需要检查他的定义moduleA.&lt;/p&gt;
&lt;p&gt;这时, 编译器会想知道”moduleA的shape是怎样的?” 这听上去很简单, moduleA可能在你写的某个 .ts/.tsx文件里或者在你的代码所依赖的.d.ts里.&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="https://xiaoxiaocoder.github.io/categories/programming/"/>
    
      <category term="javascript" scheme="https://xiaoxiaocoder.github.io/categories/programming/javascript/"/>
    
      <category term="typescript" scheme="https://xiaoxiaocoder.github.io/categories/programming/javascript/typescript/"/>
    
    
      <category term="typescript" scheme="https://xiaoxiaocoder.github.io/tags/typescript/"/>
    
      <category term="modules" scheme="https://xiaoxiaocoder.github.io/tags/modules/"/>
    
      <category term="namespaces" scheme="https://xiaoxiaocoder.github.io/tags/namespaces/"/>
    
  </entry>
  
  <entry>
    <title>[TypeScript 13]手册指南: 命名空间和模块</title>
    <link href="https://xiaoxiaocoder.github.io/programming/javascript/typescript/2017-08-22-typescript-13-namespacs-and-modules.html"/>
    <id>https://xiaoxiaocoder.github.io/programming/javascript/typescript/2017-08-22-typescript-13-namespacs-and-modules.html</id>
    <published>2017-08-22T06:38:31.000Z</published>
    <updated>2017-12-09T06:32:33.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于术语的一点说明: 请务必注意一点，TypeScript 1.5里术语名已经发生了变化。 “内部模块”现在称做“命名空间”。 “外部模块”现在则简称为“模块”，这是为了与 ECMAScript 2015里的术语保持一致，(也就是说 module X {    相当于现在推荐的写法 namespace X {)。</p></blockquote><p><strong>介绍</strong><br>这篇文章将概括介绍在TypeScript里使用模块与命名空间来组织diamante的方法. 我们也会谈及命名空间和模块的高级使用场景, 和在使用它们的过程中常见的陷阱.</p><p>查看<a href="https://www.tslang.cn/docs/handbook/modules.html" target="_blank" rel="noopener">模块</a>章节了解关于模块的更多信息。 查看 <a href="https://www.tslang.cn/docs/handbook/namespaces.html" target="_blank" rel="noopener">命名空间</a>章节了解关于命名空间的更多信息。</p><a id="more"></a><h2 id="使用命名空间"><a href="#使用命名空间" class="headerlink" title="使用命名空间"></a>使用命名空间</h2><p>命名空间是位于痊愈命名空间下的一个普通的带有名字和Javascript对象. 这令命名空间十分容易使用. 它们可以在多文件中同时使用, 并通过 –outFile 结合在一起. 命名空间是帮助你组织Web应用不错的方式, 你可以把所有依赖都放在HTML页面的&lt; script &gt;标签里.</p><p>但就像其他的全局命名空间污染一样, 它很难去识别组件之间的依赖关系,尤其是在大型的应用中.</p><h2 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h2><p>像命名空间一样,模块可以包含代码和声明. 不同的是模块可以声明它的依赖.</p><p>模块会吧依赖添加到模块的加载器上(如 Commonjs/ Requirejs). 对于小型的js应用来说可能没必要, 但是对于大型应用, 这一点点的花费会带来长久的模块化和可维护性上的便利. 模块也提供了更好的代码重用,更强的封闭性以及更好的使用工具进行优化.</p><p>对于Node.js 应用来说, 模块是默认并推荐的组织代码的方式.</p><p>从ECMAScript 2015开始, 模块称为语言内置的部分,应该会被所有正常的解释引擎所支持. 因此, 对于新项目来说推荐使用模块作为组织代码的方式.</p><h2 id="命名空间和模块的陷阱"><a href="#命名空间和模块的陷阱" class="headerlink" title="命名空间和模块的陷阱"></a>命名空间和模块的陷阱</h2><p>这部分我们会描述常见的命名空阿金和模块的使用陷阱和如何去避免它们.</p><h3 id="对模块的使用"><a href="#对模块的使用" class="headerlink" title="对模块的使用 /// "></a>对模块的使用 /// <reference></reference></h3><p>一个常见的错误是使用///<reference> 引用模块文件, 应该使用import. 要理解这之间的区别, 我们首先应该弄清编译器是如何根据import 路径(如, import x from ‘…’; 或 import x =require(“…”)里面的…, 等)来定位模块的类型信息的.</reference></p><p>编译器首先尝试去查找相应路径下的.ts, .tsx再或者 .d.ts. 如果这些文件都找不到, 编译器会查找 外部模块声明. 回想一下, 它们实在.d.ts文件里声明的.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//myModules.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//In a .d.ts file or .ts file that is not a module:</span></span><br><span class="line">declare <span class="built_in">module</span> <span class="string">"SomeModule"</span> &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) :<span class="title">string</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//<span class="title">myOtherMudule</span>.<span class="title">ts</span></span></span><br><span class="line"><span class="function">///&lt;<span class="title">reference</span> <span class="title">path</span>="<span class="title">myModule</span>.<span class="title">d</span>.<span class="title">ts</span>" /&gt;</span></span><br><span class="line"><span class="function"><span class="title">import</span> * <span class="title">as</span> <span class="title">from</span> "<span class="title">SomeModule</span>"</span></span><br></pre></td></tr></table></figure></p><p>这里的引用标签制定了外来模块的位置. 这就是一些TypeScript例子中引用的 node.d.ts的方法.</p><h3 id="不必要的命名空间"><a href="#不必要的命名空间" class="headerlink" title="不必要的命名空间"></a>不必要的命名空间</h3><p>如果你想把命名空间转换为模块, 它可能回想下面这个文件一样:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .shape.ts</span></span><br><span class="line"><span class="keyword">export</span> namespace Shapes &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>顶层的Shape包裹了Triangle和Square. 对于使用它的人来说这是令人迷惑和讨厌的:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//shapeConsumer.ts</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> shapes <span class="keyword">from</span> <span class="string">'./shapes'</span>;</span><br><span class="line"><span class="keyword">let</span> t= <span class="keyword">new</span> shapes.Shapes.Triangle(); <span class="comment">/// shapes.Shapes;</span></span><br></pre></td></tr></table></figure></p><p>TypeScript里模块的一个特点是不同的模块永远也不会再相同的作用域内使用相同的名字. 因为使用模块的人会Wie它们命名, 所以完全没有必要把导出的符号包裹在一个命名空间里.</p><p><strong>再次重申, 不应该对模块使用命名空间, 使用命名空间是为了提供逻辑分组和避免命名冲突.</strong> 模块文件本身已经是一个逻辑分组,并且它的名字是有导入这个模块的代码指定,所以没有必要为导出的对象增加额外的模块层.</p><p>改进的例子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//shapes.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Triangle</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//shapeConsumer.ts</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> shapes <span class="keyword">from</span> <span class="string">'./shapes'</span>;</span><br><span class="line"><span class="keyword">let</span> t=<span class="keyword">new</span>  shapes.Triangle();</span><br></pre></td></tr></table></figure></p><h3 id="模块的取舍"><a href="#模块的取舍" class="headerlink" title="模块的取舍"></a>模块的取舍</h3><p>就像每个JS文件对应一个模块一样,TypeScript 里模块文件与生成的JS文件也是一一 对应的. 这回产生一种影响, 根据你指定的目标模块系统的不同, 你可能无法连接多个模块源文件. 例如当目标模块系统为commonjs或umd时,无法使用outFile选项, 但是在TypeScript 1.8以上的版本里<a href="https://www.tslang.cn/docs/release-notes/typescript-1.8.html#concatenate-amd-and-system-modules-with---outfile" target="_blank" rel="noopener">能够</a>使用outFile当目标为amd或system.</p><p>The End!</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;关于术语的一点说明: 请务必注意一点，TypeScript 1.5里术语名已经发生了变化。 “内部模块”现在称做“命名空间”。 “外部模块”现在则简称为“模块”，这是为了与 ECMAScript 2015里的术语保持一致，(也就是说 module X {    相当于现在推荐的写法 namespace X {)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;br&gt;这篇文章将概括介绍在TypeScript里使用模块与命名空间来组织diamante的方法. 我们也会谈及命名空间和模块的高级使用场景, 和在使用它们的过程中常见的陷阱.&lt;/p&gt;
&lt;p&gt;查看&lt;a href=&quot;https://www.tslang.cn/docs/handbook/modules.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;模块&lt;/a&gt;章节了解关于模块的更多信息。 查看 &lt;a href=&quot;https://www.tslang.cn/docs/handbook/namespaces.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;命名空间&lt;/a&gt;章节了解关于命名空间的更多信息。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="https://xiaoxiaocoder.github.io/categories/programming/"/>
    
      <category term="javascript" scheme="https://xiaoxiaocoder.github.io/categories/programming/javascript/"/>
    
      <category term="typescript" scheme="https://xiaoxiaocoder.github.io/categories/programming/javascript/typescript/"/>
    
    
      <category term="typescript" scheme="https://xiaoxiaocoder.github.io/tags/typescript/"/>
    
      <category term="modules" scheme="https://xiaoxiaocoder.github.io/tags/modules/"/>
    
      <category term="namespaces" scheme="https://xiaoxiaocoder.github.io/tags/namespaces/"/>
    
  </entry>
  
  <entry>
    <title>[TypeScript 12]手册指南: 命名空间</title>
    <link href="https://xiaoxiaocoder.github.io/programming/javascript/typescript/2017-08-22-typescript-12-namespaces.html"/>
    <id>https://xiaoxiaocoder.github.io/programming/javascript/typescript/2017-08-22-typescript-12-namespaces.html</id>
    <published>2017-08-22T01:27:11.000Z</published>
    <updated>2017-12-09T06:32:33.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>关于术语一点说明</strong>: 务必注意一点, Typescript 1.5里术语语句已经发生了变化. “内部模块”现在称作”命名空间”. “外部模块”现在则简称为”模块”, 这是为了与 ECMAScript 2015里的术语保持一致,(也就是说 module X{ 相当于现在推荐的写法 namespace x { )</p></blockquote><p><strong>介绍</strong><br>这篇文章描述了如何在Typescript里使用命名空间(之前叫做”内部模块”)来组织你的代码. 就像我们在术语说明里提到的那样, “内部模块”现在叫做”命名空间”. 另外, 任何使用module关键字来声明一个内部模块的地方都应该使用namespace关键字来替换. 这就避免了让新的使用者被相似的名称所迷惑.</p><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>定义几个简单的字符串验证器, 假设你会使用它们来验证表单里的用户输入或验证外部数据.</p><a id="more"></a><h3 id="所有的验证器都放在一个文件里"><a href="#所有的验证器都放在一个文件里" class="headerlink" title="所有的验证器都放在一个文件里"></a>所有的验证器都放在一个文件里</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">interface StringValidator &#123;</span><br><span class="line">    isAcceptable(s: string): boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> letterRegexp =<span class="regexp">/^[a-zA-Z]+$/</span>;</span><br><span class="line"><span class="keyword">let</span> numberRegexp =<span class="regexp">/^[0-9]+$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LettersOnlyValidator</span> <span class="title">implements</span> <span class="title">StringValidator</span> </span>&#123;</span><br><span class="line">    isAcceptable(s: string)&#123;</span><br><span class="line">        <span class="keyword">return</span> letterRegexp.test(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZipCodeValidator</span> <span class="title">implements</span> <span class="title">StringValidator</span> </span>&#123;</span><br><span class="line">    isAcceptable(s: string)&#123;</span><br><span class="line">        <span class="keyword">return</span> s.length ===<span class="number">5</span> &amp;&amp; numberRegexp.test(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Some samples to try</span></span><br><span class="line"><span class="keyword">let</span> strings =[<span class="string">"hello"</span>,<span class="string">"12312"</span>,<span class="string">"23"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//Validators to use</span></span><br><span class="line"><span class="keyword">let</span> validators: &#123;[s:string]:StringValidator;&#125;=&#123;&#125;;</span><br><span class="line">validators[<span class="string">"ZIP code"</span>]=<span class="keyword">new</span> ZipCodeValidator();</span><br><span class="line">validators[<span class="string">"Letters only"</span>]= <span class="keyword">new</span> LettersOnlyValidator();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Show whether each string passed each validator</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> s <span class="keyword">of</span> strings)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> name <span class="keyword">in</span> validators)&#123;</span><br><span class="line">        <span class="keyword">let</span> isMatch = validators[name].isAcceptable(s);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`'<span class="subst">$&#123;s&#125;</span>' <span class="subst">$&#123; isMatch ? <span class="string">"matches"</span> :<span class="string">" does not match"</span>&#125;</span> '<span class="subst">$&#123;name&#125;</span>'.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>随着更多验证器的加入, 我们需要一种手段来组织代码, 以便于在记录它们类型的同事还不用担心与其他对象产生命名冲突. 因此, 我们把验证器包裹到一个命名空间内, 而不是把它们放在全局命名空间下.</p><p>下面的例子里, 把所有与验证器相关的类型都放在一个叫做Validation的命名空间里. 因为我们想让这些接口和类在命名空间之外也是可访问的, 所以需要使用 export. 相反的, 变量 lettersRegexp和 numberRegexp是实现的细节, 不需要导出, 因此它们在命名空间外是不能访问的. 在文件末尾的测试代码里, 由于是在命名空间之外访问, 因此需要限定类型的名称, 比如 Validation.LettersOnlyValidator.</p><h3 id="使用命名空间的验证器"><a href="#使用命名空间的验证器" class="headerlink" title="使用命名空间的验证器"></a>使用命名空间的验证器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">namespace Validation &#123;</span><br><span class="line">    <span class="keyword">export</span> interface StringValidator &#123;</span><br><span class="line">        isAcceptable(s: string): boolean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> lettersRegexp = <span class="regexp">/^[A-Za-z]+$/</span>;</span><br><span class="line">    <span class="keyword">const</span> numberRegexp = <span class="regexp">/^[0-9]+$/</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">LettersOnlyValidator</span> <span class="title">implements</span> <span class="title">StringValidator</span> </span>&#123;</span><br><span class="line">        isAcceptable (s: string)&#123;</span><br><span class="line">            <span class="keyword">return</span> lettersRegexp.test(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ZipCodeValidator</span> <span class="title">implements</span> <span class="title">StringValidator</span> </span>&#123;</span><br><span class="line">        isAcceptable(s: string)&#123;</span><br><span class="line">            <span class="keyword">return</span> s.length ===<span class="number">5</span> &amp;&amp; numberRegexp.test(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//some samples to try</span></span><br><span class="line"><span class="keyword">let</span> strings =[<span class="string">"hello"</span>,<span class="string">"12312"</span>,<span class="string">"123"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//Validators to use</span></span><br><span class="line"><span class="keyword">let</span> validators : &#123; [s:string] : Validation.StringValidator;  &#125;=&#123;&#125;</span><br><span class="line">validators[<span class="string">"ZIP code"</span>]=<span class="keyword">new</span> Validation.ZipCodeValidator();</span><br><span class="line">validators[<span class="string">"Letters only"</span>] =<span class="keyword">new</span> Validation.LettersOnlyValidator();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Show whether each string passed each validator</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> s <span class="keyword">of</span> strings)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> name <span class="keyword">in</span> validators)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`"<span class="subst">$&#123;s&#125;</span>" - <span class="subst">$&#123; validatots[name].isAcceptable(s)? <span class="string">"matches"</span> :<span class="string">" does not match"</span>&#125;</span> <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分离到多文件"><a href="#分离到多文件" class="headerlink" title="分离到多文件"></a>分离到多文件</h2><p>当应用变得越来越大时, 我们需要将代码分离到不同的文件中以便维护.</p><h3 id="多个文件中的命名空间"><a href="#多个文件中的命名空间" class="headerlink" title="多个文件中的命名空间"></a>多个文件中的命名空间</h3><p>现在,我们把Validation命名空间分割成多个文件. 尽管是不同的文件, 它们仍是同一个命名空间, 并且在使用的时候就如同它们在一个文件中定义的一样. 因为不同文件之间存在的依赖关系, 所以我们加入了引入标签来告诉编译器文件之间的关联. 我们的测试代码保持不变.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Validation.ts</span></span><br><span class="line">namespace Validation &#123;</span><br><span class="line">    <span class="keyword">export</span> interface StringValidator &#123;</span><br><span class="line">        isAcceptable(s:string):boolean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LettersOnlyValidator.ts</span></span><br><span class="line"><span class="comment">///&lt;reference path="Validation.ts" /&gt;</span></span><br><span class="line">namespace Validation&#123;</span><br><span class="line">    <span class="keyword">const</span> lettersRegexp =<span class="regexp">/^[a-zA-Z]+$/</span>;</span><br><span class="line">    <span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">LettersOnlyValidator</span> <span class="title">implements</span> <span class="title">StringValidator</span> </span>&#123;</span><br><span class="line">        isAcceptable(s:string)&#123;</span><br><span class="line">            <span class="keyword">return</span> lettersRegexp.test(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ZipCodeValidator.ts</span></span><br><span class="line"><span class="comment">/// &lt;reference path="Validation.ts"&gt;</span></span><br><span class="line">namespace Validation &#123;</span><br><span class="line">    <span class="keyword">const</span> numberRegexp = <span class="regexp">/^[0-9]+$/</span>;</span><br><span class="line">    <span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ZipCodeValidator</span> <span class="title">implements</span> <span class="title">StringValidator</span> </span>&#123;</span><br><span class="line">        isAcceptable(s :string)&#123;</span><br><span class="line">            <span class="keyword">return</span> s.length ===<span class="number">5</span> &amp;&amp; numberRegexp.test(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test.ts</span></span><br><span class="line"><span class="comment">/// &lt;reference path="Validation.ts" /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference path="LettersOnlyValidator.ts" /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference path="ZipCodeValidator.ts" /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//some samples to try</span></span><br><span class="line"><span class="keyword">let</span> strings =[<span class="string">"Hello"</span>,<span class="string">"12312"</span>,<span class="string">"222"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//Validators to use</span></span><br><span class="line"><span class="keyword">let</span> validators: &#123; [s:string]: Validation.StringValidator;&#125;=&#123;&#125;;</span><br><span class="line">validators[<span class="string">"ZIP code"</span>]= <span class="keyword">new</span> Validation.ZipCodeValidator();</span><br><span class="line">validators[<span class="string">"Letters only"</span>]=<span class="keyword">new</span> Validation.LettersOnlyValidator();</span><br><span class="line"></span><br><span class="line"><span class="comment">//show whether each string passed each validator</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> s <span class="keyword">of</span> strings)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> name <span class="keyword">in</span> validators)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">""</span><span class="string">" + s + "</span><span class="string">" "</span>+(validators[name].isAcceptable(s)? <span class="string">"matches"</span> :<span class="string">"does not match"</span>)+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当涉及到多个文件时, 我们必须确保所有编译后的代码都被加载了. 有两种方式.</p><ul><li>第一种方式, 把所有的输入文件编译为一个输出文件, 需要使用 –outFile标记:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --outFile sample.js test.ts</span><br></pre></td></tr></table></figure></li></ul><p>编译器会根据源码里的引用标签自动地对输出进行排序. 你可以单独地指定每个文件.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --outFile sample.js Validation.ts LettersOnlyValidator.ts ZipCodeValidator.ts Test.ts</span><br></pre></td></tr></table></figure></p><ul><li>第二种方式, 我们可以编译每一个文件(默认方式), name每个源文件都会对应生成一个Javascript文件. 然后,在页面上通过&lt; script &gt;标签把所有生成的Javascript文件按正确的顺序引进来. 如:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//myTestPage.html</span></span><br><span class="line"></span><br><span class="line">&lt;script src=<span class="string">"Validation.js"</span> type=<span class="string">"text/javascript"</span> /&gt;</span><br><span class="line">&lt;script src=<span class="string">"LettersOnlyValidator.js"</span> type=<span class="string">"text/javascript"</span> /&gt;</span><br><span class="line">&lt;script src=<span class="string">"ZipCodeValidator.js"</span> type=<span class="string">"text/javascript"</span> /&gt;</span><br><span class="line">&lt;script src=<span class="string">"Test.js"</span> type=<span class="string">"text/javascript"</span> /&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><p>另一种简化命名空间操作的方法是使用 import q=x.y.z 给常用的对象起一个短名字. 不要与用来加载模块的 import x= require(‘name’) 语法弄混了, 这里的语法是为指定的符号创建一个别名. 你可以用这种方法为任意标识符创建别名,也包含导入的模块的对象.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">namespace Shapes &#123;</span><br><span class="line">    <span class="keyword">export</span> namespace Polygons &#123;</span><br><span class="line">        <span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> </span>&#123;&#125;</span><br><span class="line">        <span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> polygons =Shapes.Polygons;</span><br><span class="line"><span class="keyword">let</span> sq =<span class="keyword">new</span> polygons.Square(); <span class="comment">//same as 'new Shapes.Polygons.Square()'</span></span><br></pre></td></tr></table></figure></p><p>注意, 我们并没有使用require关键字,而是直接使用导入符号的限定名赋值. 这与使用var相似, 但它还适用于类型和导入的具有命名空间含义的符号. 重要的是, 对于值来讲, import会生成与原始符号不同的引用的引用, 所以改变别名的var值并不会影响原始变量的值.</p><h2 id="使用其他的Javascript库"><a href="#使用其他的Javascript库" class="headerlink" title="使用其他的Javascript库"></a>使用其他的Javascript库</h2><p>为了描述不是用TypeScript编写的类库的类型, 我们需要声明类库导出的API. 由于大部分程序库只提供少出的顶级对象, 命名空间是用来表示它们一个好办法.</p><p>我们称其为声明时因为它不是外部程序的具体实现. 我们通常在.d.ts里写这些声明. </p><h3 id="外部命名空间"><a href="#外部命名空间" class="headerlink" title="外部命名空间"></a>外部命名空间</h3><p>流行的程序D3在全局对象d3里定义它的功能. 因为这个库通过一个&lt; script &gt; 标签加载(不是通过模块加载器), 它的声明文件使用内部模块来定义它的类型. 为了让TypeScript编译器识别它的类型, 我们使用外部命名空间声明. 如:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">declare namespace D3&#123;</span><br><span class="line">    <span class="keyword">export</span> interface Selectors &#123;</span><br><span class="line">        select:&#123;</span><br><span class="line">            (selector :string) :Selection;</span><br><span class="line">            (element: EventTarget): Selection;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">export</span> interface Event &#123;</span><br><span class="line">        x: number;</span><br><span class="line">        y: number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">export</span> interface Base extends Selectors&#123;</span><br><span class="line">        event: Event;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare <span class="keyword">var</span> d3: D3.Base;</span><br></pre></td></tr></table></figure></p><p>The End!</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;关于术语一点说明&lt;/strong&gt;: 务必注意一点, Typescript 1.5里术语语句已经发生了变化. “内部模块”现在称作”命名空间”. “外部模块”现在则简称为”模块”, 这是为了与 ECMAScript 2015里的术语保持一致,(也就是说 module X{ 相当于现在推荐的写法 namespace x { )&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;br&gt;这篇文章描述了如何在Typescript里使用命名空间(之前叫做”内部模块”)来组织你的代码. 就像我们在术语说明里提到的那样, “内部模块”现在叫做”命名空间”. 另外, 任何使用module关键字来声明一个内部模块的地方都应该使用namespace关键字来替换. 这就避免了让新的使用者被相似的名称所迷惑.&lt;/p&gt;
&lt;h2 id=&quot;第一步&quot;&gt;&lt;a href=&quot;#第一步&quot; class=&quot;headerlink&quot; title=&quot;第一步&quot;&gt;&lt;/a&gt;第一步&lt;/h2&gt;&lt;p&gt;定义几个简单的字符串验证器, 假设你会使用它们来验证表单里的用户输入或验证外部数据.&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="https://xiaoxiaocoder.github.io/categories/programming/"/>
    
      <category term="javascript" scheme="https://xiaoxiaocoder.github.io/categories/programming/javascript/"/>
    
      <category term="typescript" scheme="https://xiaoxiaocoder.github.io/categories/programming/javascript/typescript/"/>
    
    
      <category term="typescript" scheme="https://xiaoxiaocoder.github.io/tags/typescript/"/>
    
      <category term="namespaces" scheme="https://xiaoxiaocoder.github.io/tags/namespaces/"/>
    
  </entry>
  
  <entry>
    <title>[TypeScript 11]手册指南: 模块</title>
    <link href="https://xiaoxiaocoder.github.io/programming/javascript/typescript/2017-08-19-typescript-11-modules.html"/>
    <id>https://xiaoxiaocoder.github.io/programming/javascript/typescript/2017-08-19-typescript-11-modules.html</id>
    <published>2017-08-19T15:12:02.000Z</published>
    <updated>2017-12-09T06:32:33.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>关于术语的一点说明:</strong> 请务必注意一点, TypeScript 1.5里术语已经发生了变化. “内部模块”现在称作”命名空间”. “外部模块”闲杂简称”模块”. 这是为了与ECMAScript 2015里的术语保持一致(也就是说 moduele X{ 相当于现在推荐的写法 namespace X{) </p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>从ECMAScript 2015开始, javascript引入了模块的概念. Typescript也沿用了这个概念.</p><p>模块在其自身的作用域里执行,而不是全局作用域里; 这意味着定义在一个模块里的变量,函数,类等等在模块外部是不可见的, 除非明确地私用 <a href="https://www.tslang.cn/docs/handbook/modules.html#export" target="_blank" rel="noopener">export</a>之一导出它们. 相反, 如果想使用其它模块导出的变量,函数,类,接口等的时候, 你必须导入它们, 可以使用 <a href="https://www.tslang.cn/docs/handbook/modules.html#import" target="_blank" rel="noopener">import</a>形式之一</p><a id="more"></a><p>模块是自声明的;连个模块之间的管事是通过在文件级别使用imports和exports建立的.<br>模块使用模块加载器去导入其它的模块. 在运行时,模块加载器的作用是在执行此模块代码前查找并执行这个模块的所有依赖. 大家最熟悉的javascript模块加载器是服务于nodejs的CommonJS和服务于Web应用的Requirejs</p><p>TypeScript与ECMAScript 2015一样, 任何包含顶级import或者export的文件都被当成一个模块.</p><h2 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h2><h3 id="导出声明"><a href="#导出声明" class="headerlink" title="导出声明"></a>导出声明</h3><p>任何声明(比如变量,函数,类,类型别名或接口)都能通过添加export关键字来导出.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//export interface</span></span><br><span class="line"><span class="keyword">export</span> interface StringValidator&#123;</span><br><span class="line">    isAcceptable(s:string):boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//export variable,class</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> numberRegexp =<span class="regexp">/^[0-9]+$/</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ZipCodeValidator</span> <span class="title">implements</span> <span class="title">StringValidator</span> </span>&#123;</span><br><span class="line">    isAcceptable(s:string)&#123;</span><br><span class="line">        <span class="keyword">return</span> s.length===<span class="number">5</span> &amp;&amp; numberRegexp.test(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="导出语句"><a href="#导出语句" class="headerlink" title="导出语句"></a>导出语句</h3><p>导出语句很便利, 因为我们可能需要对导出的部分重命名,所以上面的例子可以这样改写:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZipCodeValidator</span> <span class="title">implements</span> <span class="title">StringValidator</span> </span>&#123;</span><br><span class="line">    isAcceptable(s: string)&#123;</span><br><span class="line">        <span class="keyword">return</span> s.length===<span class="number">5</span> &amp;&amp; numberRegexp.test(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;ZipCodeValidator&#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; ZipCodeValidator <span class="keyword">as</span> mainValidator &#125;;</span><br></pre></td></tr></table></figure></p><h3 id="重新导出"><a href="#重新导出" class="headerlink" title="重新导出"></a>重新导出</h3><p>我们经常会去扩展其他模块, 并且只导出那个模块的部分内容. 重新导出功能并不会再当前模块导入那个模块或定义一个新的局部变量.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseIntBasedZipCodeValidator</span> </span>&#123;</span><br><span class="line">    isAcceptable(s : string)&#123;</span><br><span class="line">        <span class="keyword">return</span> s.length===<span class="number">5</span> &amp;&amp; <span class="built_in">parseInt</span>(s).toString()===s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出原先的严正新但做了重命名</span></span><br><span class="line"><span class="keyword">export</span> &#123; ZipCodeValidator <span class="keyword">as</span> RegExpBasedZipCodeValidator &#125; <span class="keyword">from</span> <span class="string">'./ZipCodeValidator'</span>;</span><br></pre></td></tr></table></figure></p><p>或者一个模块可以包裹多个模块,并且他们导出的内容联合在一起通过语法:<code>export * from &quot;module&quot;</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./StringValidator'</span>; <span class="comment">//exports interface StringValidator;</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">"./LetterOnlyValidator"</span>; <span class="comment">//exports class LetterOnlyValidator;</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./ZipCodeValidator'</span>; <span class="comment">//exports class ZipCdeValidator</span></span><br></pre></td></tr></table></figure></p><h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><p>模块的导入操作与导出一样简单. 可以使用以下import形式之一来导入其他模块中的导出内容.</p><h3 id="导出一个模块中的某个导出内容"><a href="#导出一个模块中的某个导出内容" class="headerlink" title="导出一个模块中的某个导出内容"></a>导出一个模块中的某个导出内容</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ZipCodeValidator &#125; <span class="keyword">from</span> <span class="string">'./ZipCodeValidator'</span>;</span><br><span class="line"><span class="keyword">let</span> myValidator = <span class="keyword">new</span> ZipCodeValidator();</span><br></pre></td></tr></table></figure><p>可以对导入内容重命名<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ZipCodeValidator <span class="keyword">as</span> ZCV&#125; <span class="keyword">from</span> <span class="string">'./ZipCodeValidator'</span>;</span><br><span class="line"><span class="keyword">let</span> myValidator=<span class="keyword">new</span> ZCV();</span><br></pre></td></tr></table></figure></p><h3 id="将整个模块导入到一个变量-并通过它来访问模块的导出部分"><a href="#将整个模块导入到一个变量-并通过它来访问模块的导出部分" class="headerlink" title="将整个模块导入到一个变量,并通过它来访问模块的导出部分"></a>将整个模块导入到一个变量,并通过它来访问模块的导出部分</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> validator <span class="keyword">from</span> <span class="string">'./ZipCodeValidator'</span>;</span><br><span class="line"><span class="keyword">let</span> myValidator = <span class="keyword">new</span> validator.ZipCodeValidator();</span><br></pre></td></tr></table></figure><h3 id="具有副作用的导入模块"><a href="#具有副作用的导入模块" class="headerlink" title="具有副作用的导入模块"></a>具有副作用的导入模块</h3><p>尽管不推荐这么做, 一些模块会设置一些全局状态供其他模块使用. 这些模块可能没有任何的导出或用户根部就不关注它的导出. 使用下面的方法来导入这些模块:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"./my-module.js"</span></span><br></pre></td></tr></table></figure></p><h2 id="默认导出"><a href="#默认导出" class="headerlink" title="默认导出"></a>默认导出</h2><p>每个模块都可以有一个default导出. 默认导出使用default关键字标记; <strong>并且一个模块只能够有一个default导出.</strong>需要使用一种特殊的导入形式来导入default导出.</p><p>default导出十分便利. 比如, 像JQuery这样的类库可能有一个默认导出jQuery或$, 并且我们基本上也会使用童颜的名字jQuery或$导出jQuery.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">declare <span class="keyword">let</span> $ :JQuery;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> $;</span><br><span class="line"></span><br><span class="line"><span class="comment">//app.ts</span></span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'JQuery'</span>;</span><br><span class="line">$(<span class="string">'button.continue'</span>).html(<span class="string">'next step...'</span>);</span><br></pre></td></tr></table></figure></p><p>类和函数声明可以直接被标记为默认导出. 表弟为默认导出的类和函数的名字是可以省略的.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//zipcodevalidator.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ZipCodeValidator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> numberRegexp=<span class="regexp">/^[0-9]+$/</span>;</span><br><span class="line">    isAcceptable(s:string)&#123;</span><br><span class="line">        <span class="keyword">return</span> s.length===s &amp;&amp; ZipCodeValidator.numberRegexp.test(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test.ts</span></span><br><span class="line"><span class="keyword">import</span> validator <span class="keyword">from</span> <span class="string">'./ZipCodeValidator'</span></span><br><span class="line"><span class="keyword">let</span> myValidator =<span class="keyword">new</span> validator();</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//staticzipcodevalidator</span></span><br><span class="line"><span class="keyword">const</span> numberRegexp =<span class="regexp">/^[0-9]+$/</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">s:string</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.length===<span class="number">5</span> &amp;&amp; numberRegexp.test(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test.ts</span></span><br><span class="line"><span class="keyword">import</span> validate <span class="keyword">from</span> <span class="string">'./StaticZipCodeValidator'</span>;</span><br><span class="line"><span class="keyword">let</span> strings=[<span class="string">"Hello"</span>,<span class="string">"21123"</span>,<span class="string">"101"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//use function validate</span></span><br><span class="line">strings.forEach(<span class="function"><span class="params">s</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`"<span class="subst">$&#123;s&#125;</span>" <span class="subst">$&#123;validate(s)?<span class="string">"matches"</span>:<span class="string">"does not match"</span>&#125;</span>`</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><strong>default</strong>导出也可以是一个值<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//onetwothree.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">"123"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//log.ts</span></span><br><span class="line"><span class="keyword">import</span> num <span class="keyword">from</span> <span class="string">"./OneTwoThree"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">//"123";</span></span><br></pre></td></tr></table></figure></p><h3 id="export-和-import-require"><a href="#export-和-import-require" class="headerlink" title="export= 和 import=require()"></a>export= 和 import=require()</h3><p>CommonJS和AMD都有一个exports对象的概念,它包含一个模块的所有导出内容.<br>他们也支持把exports替换为一个自定义对象. 默认导出就好比这样一个功能; 然后,它们却并不相互兼容. TypeScript模块支持export= 语法以支持传统的CommonJS 和 AMD的工作流模型.<br>export= 语法定义一个模块的导出对象. 它可以是类,接口,命名空间,函数或枚举<br>若要导入一个<strong>export=</strong>的模块时,必须使用TypeScript提供的特定语法<strong>import module=require(‘module’)</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ZipCodeValidator.ts</span></span><br><span class="line"><span class="keyword">let</span> numberRegexp = <span class="regexp">/^[0-9]+$/</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">ZipCodeValidator</span> </span>&#123;</span><br><span class="line">    isAcceptable(s: string)&#123;</span><br><span class="line">        <span class="keyword">return</span> s.length===<span class="number">5</span> &amp;&amp; numberRegexp.test(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> = ZipCodeValidator;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test.ts</span></span><br><span class="line"><span class="keyword">import</span> zip = <span class="built_in">require</span>(<span class="string">"./ZipCodeValidator"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//some samples to try</span></span><br><span class="line"><span class="keyword">let</span> strings =[<span class="string">"hello"</span>,<span class="string">"12332"</span>,<span class="string">"123"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//validator to use</span></span><br><span class="line"><span class="keyword">let</span> validator = <span class="keyword">new</span> zip();</span><br><span class="line"></span><br><span class="line"><span class="comment">//show whether each string passed each validator</span></span><br><span class="line">strings.forEach(<span class="function"><span class="params">s</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`"<span class="subst">$&#123;s&#125;</span>" - <span class="subst">$&#123; validator.isAcceptable(s) ? <span class="string">"matches"</span> :<span class="string">"does not match"</span>&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="生成模块代码"><a href="#生成模块代码" class="headerlink" title="生成模块代码"></a>生成模块代码</h2><p>根据编译时指定的模块目标参数,编译器会生成相应的供Node.js(CommonJS), Requirejs(AMD), isomorphic(UMD), SystemJS 或 ECMAScript 2015 native modules(ES6)模块加载系统使用的代码. 想要了解生成代码中define, require和 register的意义,请参考乡音模块的加载器的文档.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//simpleModule.ts</span></span><br><span class="line"><span class="keyword">import</span> m= <span class="built_in">require</span>(<span class="string">"mod"</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> t=m.something +<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AMD / RequireJS SimpleModule.js</span></span><br><span class="line">define([<span class="string">"require"</span>,<span class="string">"exports"</span>,<span class="string">"./mod"</span>],<span class="function"><span class="keyword">function</span>(<span class="params">require,exports,mod_1</span>)</span>&#123;</span><br><span class="line">    exports.t=mod_1.something +<span class="number">1</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Commonjs/ Node SimpleModule.js</span></span><br><span class="line"><span class="keyword">let</span> mod_1=<span class="built_in">require</span>(<span class="string">"./mod"</span>);</span><br><span class="line">exports.t=mod_1.something +<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//UMD SimpleModule.js</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">factory</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(typepf <span class="built_in">module</span> ===<span class="string">"object"</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span>.exports ===<span class="string">"object"</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> v=factory(<span class="built_in">require</span>,exports);</span><br><span class="line">        <span class="keyword">if</span>(v !==<span class="literal">undefined</span>)&#123;</span><br><span class="line">            <span class="built_in">module</span>.exports=v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> define=== <span class="string">"function"</span> &amp;&amp; define.amd)&#123;</span><br><span class="line">        define([<span class="string">"require"</span>,<span class="string">"exports"</span>,<span class="string">"./mod"</span>],factory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(<span class="function"><span class="keyword">function</span>(<span class="params">require,exports</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> mod_1=<span class="built_in">require</span>(<span class="string">"./mod"</span>);</span><br><span class="line">    exports.t=mod_1.something +<span class="number">1</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//System SimpleModule.js</span></span><br><span class="line">System.register([<span class="string">'./mod'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">exports_1</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> mod_1;</span><br><span class="line">    <span class="keyword">let</span> t;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        setters:[</span><br><span class="line">            <span class="function"><span class="keyword">function</span>(<span class="params">mod_1_1</span>)</span>&#123;</span><br><span class="line">                mod_1=mod_1_1;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        execute:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            exports_1(<span class="string">"t"</span>,t=mod_1.something +<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Native ECMAScript 2015 modules SimppleModule.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; something &#125; <span class="keyword">from</span> <span class="string">"./mod"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> t= something +<span class="number">1</span>;</span><br></pre></td></tr></table></figure></p><h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><p>下面我们来整理一下前面的验证器实现,每个模块只有一个命名的导出.</p><p>为了编译,我们必须要在命令行上指定一个模块目标. 对于Node.js来说, 使用–module commonjs; 对于require.js来说, 使用”–module amd”. 如:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --<span class="built_in">module</span> commonjs test.ts</span><br></pre></td></tr></table></figure></p><p>编译完成后, 每个模块会生成一个单独的.js文件. 好比使用了reference标签,编译器会根据import语句编译相应的文件.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//validation.ts</span></span><br><span class="line"><span class="keyword">export</span> interface StringValidator&#123;</span><br><span class="line">    isAcceptable(s:<span class="built_in">String</span>):boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LetterOnlyValidator.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123;StringValidator&#125; <span class="keyword">from</span> <span class="string">'./Validation'</span>;</span><br><span class="line"><span class="keyword">const</span> lettersRegexp =<span class="regexp">/^[A-Za-z]+$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">LetterOnlyValidator</span> <span class="title">implements</span> <span class="title">StringValidator</span></span>&#123;</span><br><span class="line">    isAcceptable(s:string)&#123;</span><br><span class="line">        <span class="keyword">return</span> letterRegexp.test(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ZipCodeValidator.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; SringValidator &#125; <span class="keyword">from</span> <span class="string">'./Validation'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numberRegexp =<span class="regexp">/^[0-9]+$/</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ZipCodeValidator</span> <span class="title">implements</span> <span class="title">StringValidator</span> </span>&#123;</span><br><span class="line">    isAcceptable(s:string)&#123;</span><br><span class="line">        <span class="keyword">return</span> s.length===<span class="number">5</span> &amp;&amp; numberRegexp.test(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Test.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; StringValidator &#125; <span class="keyword">from</span> <span class="string">'./Validation'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ZipCodeValidator &#125; <span class="keyword">from</span> <span class="string">'./ZipCodeValidator'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; LetterOnlyValidator &#125; <span class="keyword">from</span> <span class="string">'./LettersOnlyValidator'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//some samples to try</span></span><br><span class="line"><span class="keyword">let</span> strings=[<span class="string">"hello"</span>,<span class="string">"12334"</span>,<span class="string">"123"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//Validators to use</span></span><br><span class="line"><span class="keyword">let</span> validators: &#123; [s:string]: StringValidator;&#125;=&#123;&#125;</span><br><span class="line">validators[<span class="string">"ZIP CODE"</span>]=<span class="keyword">new</span> ZipCodeValidator();</span><br><span class="line">validators[<span class="string">"letters only"</span>]=<span class="keyword">new</span> LettersOnlyValidaator();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Show whether each string passed each validator</span></span><br><span class="line">strings.forEach(<span class="function"><span class="params">s</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> name <span class="keyword">in</span> validators)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`"<span class="subst">$&#123;s&#125;</span>"-<span class="subst">$&#123;validators[name].isAcceptable(s)? <span class="string">"matches"</span>:<span class="string">"does not match"</span>&#125;</span> <span class="subst">$&#123;name&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="可选的模块加载和其他高级加载场景"><a href="#可选的模块加载和其他高级加载场景" class="headerlink" title="可选的模块加载和其他高级加载场景"></a>可选的模块加载和其他高级加载场景</h2><p>有时,只想在某种条件下才加载某个模块</p><p>编译器会检测是否每个模块都会在生成的Javascript中用到. 如果一个模块标识符只在类型注解部分使用,并且完全没有在表达式中使用,就不会生成require这个模块的代码. 省略掉没有用到的引用对性能提升是很有益的,并且同事提供了选择性加载模块的能力.</p><p>这种模式的核心是<strong>import id=require(“…”)</strong>语句可以让我们访问模块导出的类型. 模块加载器会被动态调用(通过require),就像if代码里那样. 它利用了省略引用的优化,所以模块只在被需要时加载. 为了让这个模块工作,敌营要注意import定义的标识符只能在表示类型处使用(不能再会转换成Javascript的地方)</p><p>为了确保类型安全性,我们可以使用typeof关键字. typeof关键字,当在表示类型的覅房使用时, 会得出一个类型值,这里就表示模块的类型.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Node.js里的动态模块加载</span></span><br><span class="line">declare <span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params">moduleName:string</span>):<span class="title">any</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">import</span> </span>&#123;ZipCodeValidator <span class="keyword">as</span> Zip&#125; <span class="keyword">from</span> <span class="string">'./ZipCodeValidator'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(needZipValidation)&#123;</span><br><span class="line">    <span class="keyword">let</span> ZipCodeValidator : <span class="keyword">typeof</span> Zip =<span class="built_in">require</span>(<span class="string">"./ZipCodeValidator"</span>);</span><br><span class="line">    <span class="keyword">let</span> validator=<span class="keyword">new</span> ZipCodeValidator();</span><br><span class="line">    <span class="keyword">if</span>(validator.isAcceptable(<span class="string">"..."</span>)&#123; </span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//require.js里的动态模块加载</span></span><br><span class="line">declare <span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params">moduleName:string[],onLoad:(...args:any[]=&gt;void</span>)):<span class="title">void</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">import</span> * <span class="title">as</span> <span class="title">Zip</span> <span class="title">from</span> './<span class="title">ZipCodeValidator</span>';</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">if</span>(<span class="params">needZipValidation</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">require</span>([<span class="string">"./ZipCodeValidator"</span>],(ZipCodeValidator:<span class="keyword">typeof</span> Zip)=&gt;&#123;</span><br><span class="line">        <span class="keyword">let</span> validator =<span class="keyword">new</span> ZipCodeValidator.ZipCodeValidator();</span><br><span class="line">        <span class="keyword">if</span>(validator.isAcceptable(<span class="string">'...'</span>))&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//System.js里的动态模块加载</span></span><br><span class="line">declare <span class="keyword">const</span> System :any;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; ZipCodeValidator <span class="keyword">as</span> Zip&#125; <span class="keyword">from</span> <span class="string">'./ZipCodeValidator'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(needZipValidation)&#123;</span><br><span class="line">    System.import(<span class="string">"./ZipCodeValidator"</span>).then(<span class="function">(<span class="params">ZipCodeValidator:<span class="keyword">typeof</span> Zip</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> x=<span class="keyword">new</span> ZipCodeValidator();</span><br><span class="line">        <span class="keyword">if</span>(x.isAcceptable(<span class="string">"..."</span>))&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="使用其他的Javascript库"><a href="#使用其他的Javascript库" class="headerlink" title="使用其他的Javascript库"></a>使用其他的Javascript库</h2><p>要想描述非TypeScript编写的类库的类型, 我们需要声明类库所暴露的API.</p><p>我们叫它声明因为它不是”外部程序”的具体实现. 它们通常实在.d.ts文件里定义的.</p><h3 id="外部模块"><a href="#外部模块" class="headerlink" title="外部模块"></a>外部模块</h3><p>在Node.js里大部分工作是通过加载一个或多个模块实现的. 我们可以使用顶级的export声明为每个模块都定义一个.d.ts文件,但最好还是写在一个大的.d.ts文件里. 我们使用与构造一个外部命名空间相似的方法,但是这里使用module关键字并且把名字用引号括起来,方便之后import.如:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//node.d.ts (simplifiled excerpt)</span></span><br><span class="line">declare <span class="built_in">module</span> <span class="string">"url"</span>&#123;</span><br><span class="line">    <span class="keyword">export</span> interface Url&#123;</span><br><span class="line">        protocol?: string;</span><br><span class="line">        hostname?:string;</span><br><span class="line">        pathname?:string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params">urlStr:string, parseQueryString?, slashesSenoteHost?</span>):<span class="title">Url</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">declare</span> <span class="title">module</span> "<span class="title">path</span>" </span>&#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">normalize</span>(<span class="params">p:string</span>):<span class="title">string</span>;</span></span><br><span class="line"><span class="function">    <span class="title">export</span> <span class="title">function</span> <span class="title">join</span>(<span class="params">...paths:any[]</span>):<span class="title">string</span>;</span></span><br><span class="line"><span class="function">    <span class="title">export</span> <span class="title">let</span> <span class="title">sep</span>:<span class="title">string</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p><p>现在我们可以///<reference> node.d.ts并且使用<code>import url=require(&quot;url&quot;);</code> 或 <code>import * as URL from &quot;url&quot;</code>加载模块<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///&lt;reference path="node.d.ts" /&gt;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> URL <span class="keyword">from</span> <span class="string">"url"</span>;</span><br><span class="line"><span class="keyword">let</span> myUrl=Url.parse(<span class="string">"http://www.typescriptlang.org"</span>)</span><br></pre></td></tr></table></figure></reference></p><h3 id="外部模块简写"><a href="#外部模块简写" class="headerlink" title="外部模块简写"></a>外部模块简写</h3><p>加入你不想在使用一个新模块之前花时间去写声明,你可以采用声明的简写形式以便能够快速使用它.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//declarations.d.ts</span></span><br><span class="line">declare <span class="built_in">module</span> <span class="string">"hot-new-module"</span></span><br></pre></td></tr></table></figure></p><p>简写模块里所有导出的类型僵尸any<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> x, &#123;y&#125; <span class="keyword">from</span> <span class="string">"hot-new-module"</span></span><br><span class="line">x(y);</span><br></pre></td></tr></table></figure></p><h3 id="模块声明通配符"><a href="#模块声明通配符" class="headerlink" title="模块声明通配符"></a>模块声明通配符</h3><p>某些模块加载器如SystemJS和AMD支持导入非Javascript内容. 它们通常会使用一个前缀或后缀来表示特殊的加载语法. 模块声明通配符可以用来表示这些情况.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">declare <span class="built_in">module</span> <span class="string">"*!test"</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> content: string;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Some do it the other way around</span></span><br><span class="line">declare <span class="built_in">module</span> <span class="string">"json!*"</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> value: any;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在你可以就导入匹配”<em>!test”或”json!</em>“的内容了.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fileContent <span class="keyword">from</span> <span class="string">"./xyz.txt!test"</span>;</span><br><span class="line"><span class="keyword">import</span> data <span class="keyword">from</span> <span class="string">"json!http://example.com/data.json"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(data,fileContent);</span><br></pre></td></tr></table></figure></p><h3 id="UMD模块"><a href="#UMD模块" class="headerlink" title="UMD模块"></a>UMD模块</h3><p>有些模块被设计成兼容多个模块加载器,或者不使用模块加载器(全局变量). 它们以UMD 或!somorphic模块代表. 这些库可以通过导入的形式或全局变量的形式访问. 例如:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//math-lib.d.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isPrime(x: number):boolean;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">as</span> namespace mathLibl</span><br></pre></td></tr></table></figure></p><p>之后, 这个库可以在某个模块里通过导入来使用:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; isPrime &#125; <span class="keyword">from</span> <span class="string">"math-lib"</span>;</span><br><span class="line">isPrime(<span class="number">2</span>);</span><br><span class="line">mathLib.isPrime(<span class="number">2</span>); <span class="comment">// Error: can't use the global definition from inside a module</span></span><br></pre></td></tr></table></figure></p><p>它同样可以通过全局变量的形式使用, 但是能在某个脚本里. (脚本是指一个不带导入或导出的文件.)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mathLib.isPrime(<span class="number">2</span>);</span><br></pre></td></tr></table></figure></p><h2 id="创建模块结构知道"><a href="#创建模块结构知道" class="headerlink" title="创建模块结构知道"></a>创建模块结构知道</h2><h3 id="尽可能在顶层导出"><a href="#尽可能在顶层导出" class="headerlink" title="尽可能在顶层导出"></a>尽可能在顶层导出</h3><p>用户应该更容易地使用你模块导出的内容. 嵌套层次多会变得难以处理, 因此仔细考虑一下如何组织你的代码.</p><p>从你的模块中导出一个命名空间就是一个增加嵌套的例子. 索然命名空间有时候有它们的用户, 在使用模块的时候它们额外地增加了一层. 这对用户来说是很不便的并且通常是多余的.</p><p>导出类的静态方法也同样的问题 - 这个类本身就增加了一层嵌套. 除非它能方便标书或便于清洗使用, 否则请考虑直接导出一个辅助方法.</p><h3 id="如果仅导出单个-class-或-function-使用-export-default"><a href="#如果仅导出单个-class-或-function-使用-export-default" class="headerlink" title="如果仅导出单个 class 或 function, 使用 export default"></a>如果仅导出单个 class 或 function, 使用 export default</h3><p>就像”在顶层上导出” 帮助减少用户使用的难度, 一个默认的导出也能起到这个效果. 如果一个模块就是为了导出特定的内容, 那么你应该考虑使用一个默认导出. 这回令模块的导入和使用变得些许简单. 比如:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MyClass.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MyFunc.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">getThing</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="string">'thing'</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Consumer.ts</span></span><br><span class="line"><span class="keyword">import</span> t <span class="keyword">from</span> <span class="string">"./MyClass"</span>;</span><br><span class="line"><span class="keyword">import</span> f <span class="keyword">from</span> <span class="string">"./MyFunc"</span>;</span><br><span class="line"><span class="keyword">let</span> x=<span class="keyword">new</span> t();</span><br><span class="line"><span class="built_in">console</span>.log(f());</span><br></pre></td></tr></table></figure></p><p>对用户来说这是最理想的. 他们可以随意命名导入模型的类型(本例为t) 并且不需要多余(.) 来找到相关对象.</p><h3 id="如果要导出多个对象-把他们放在顶层里导出"><a href="#如果要导出多个对象-把他们放在顶层里导出" class="headerlink" title="如果要导出多个对象, 把他们放在顶层里导出"></a>如果要导出多个对象, 把他们放在顶层里导出</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MyThings.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeType</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">someFunc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相反地,当导入的时候:</p><h3 id="明确地列出导入的名字"><a href="#明确地列出导入的名字" class="headerlink" title="明确地列出导入的名字"></a>明确地列出导入的名字</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;SomeType, SomeFunc &#125; <span class="keyword">from</span> <span class="string">"./MyThings"</span>;</span><br><span class="line"><span class="keyword">let</span> x = <span class="keyword">new</span> SomeType();</span><br><span class="line"><span class="keyword">let</span> y = someFUnc();</span><br></pre></td></tr></table></figure><h3 id="使用命名空间导入模式当你要导出大量内容的时候"><a href="#使用命名空间导入模式当你要导出大量内容的时候" class="headerlink" title="使用命名空间导入模式当你要导出大量内容的时候"></a>使用命名空间导入模式当你要导出大量内容的时候</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MyLargeModule.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Tree</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Flower</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Consumer.ts</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> myLargeModule <span class="keyword">from</span> <span class="string">"./MyLargeModule.ts"</span>;</span><br><span class="line"><span class="keyword">let</span> x=<span class="keyword">new</span> myLargeModule.Dog();</span><br></pre></td></tr></table></figure><h3 id="使用重新导出进行扩展"><a href="#使用重新导出进行扩展" class="headerlink" title="使用重新导出进行扩展"></a>使用重新导出进行扩展</h3><p>你可能经常需要去扩展一个模块的功能. JS里常用的一个模式是JQuery那样去扩展原声对象. 如果我们之前提到的,模块不会像全局命名空间对象那样去合并. 推荐的方案是 不要去改变原来的对象,而是导出一个新的实体来提供新的功能.<br>假设Calculator.ts模块里定义了一个简单的计算器实现. 这个模块同样提供了一个辅助函数来测试计算器的功能,通过传入一系列输入的字符串并在最后给出结果.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Calculator.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    private current =<span class="number">0</span>;</span><br><span class="line">    private memory =<span class="number">0</span>;</span><br><span class="line">    private operator: sting;</span><br><span class="line"></span><br><span class="line">    protected processDigit(digit:string, <span class="attr">currentValue</span>: number)&#123;</span><br><span class="line">        <span class="keyword">if</span>(digit&gt;=<span class="string">"0"</span> &amp;&amp; digit&lt;=<span class="string">"9"</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> currentValue *<span class="number">10</span> + (digit.charCodeAt(<span class="number">0</span>) - <span class="string">"0"</span>.charCodeAt(<span class="number">0</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected processOPerator(operator:string)&#123;</span><br><span class="line">        <span class="keyword">if</span>([<span class="string">"+"</span>,<span class="string">"-"</span>,<span class="string">"*"</span>,<span class="string">"/"</span>].indexOf(operator)&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> operator;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected evaluateOperator(operator:string, <span class="attr">left</span>: number; right:number):number&#123;</span><br><span class="line">        <span class="keyword">switch</span>(<span class="keyword">this</span>.operator)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"+"</span>: <span class="keyword">return</span> left +right;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"-"</span>: <span class="keyword">return</span> left-right;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"*"</span>: <span class="keyword">return</span> left * right;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"/"</span>: <span class="keyword">return</span> left /right; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private evaluate()&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.operator)&#123;</span><br><span class="line">            <span class="keyword">this</span>.memory=<span class="keyword">this</span>.evaluateOperator(<span class="keyword">this</span>.operator,<span class="keyword">this</span>.memory,<span class="keyword">this</span>.current);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.memory=<span class="keyword">this</span>.current;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.current=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public handelChar(char:string)&#123;</span><br><span class="line">        <span class="keyword">if</span>(char ===<span class="string">"="</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.evaluate();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> value=<span class="keyword">this</span>.processDigit(char,<span class="keyword">this</span>.current);</span><br><span class="line">            <span class="keyword">if</span>(value !==<span class="literal">undefined</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.current =value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Unsupported input: '<span class="subst">$&#123;char&#125;</span>'`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public getResult()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.memory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">c:Calculator,input:string</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;input.lenght; i++)&#123;</span><br><span class="line">        c.handleChar(input[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`result of '<span class="subst">$&#123;input&#125;</span>' is '<span class="subst">$&#123;c.getResult()&#125;</span>'`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是使用导出的test函数来测试计算器.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//testCalculator.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123;Calculator, test&#125; <span class="keyword">from</span> <span class="string">'./Calculator'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c= <span class="keyword">new</span> Calculator();</span><br><span class="line">test(c,<span class="string">"1+2*33/11="</span>); <span class="comment">//print 9</span></span><br></pre></td></tr></table></figure></p><p>现在扩展它, 添加支持输入其他进制(十进制以外), 让我们来创建 ProgrammerCalculator.ts<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ProgrammerCalculator.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123;Calculator&#125; <span class="keyword">from</span> <span class="string">'./Calculator'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProgrammerCalculaor</span> <span class="keyword">extends</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    string digits=[<span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>,<span class="string">"6"</span>,<span class="string">"7"</span>,<span class="string">"8"</span>,<span class="string">"9"</span>,<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>,<span class="string">"D"</span>,<span class="string">"E"</span>,<span class="string">"F"</span>];</span><br><span class="line">    <span class="keyword">constructor</span>(public base:number)&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">if</span>(base&lt;=<span class="number">0</span> || base&gt; ProgrammerCalculator.digits.length)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"base has to be within 0 to 16 inclusice."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected processDigit(digit:string, <span class="attr">currentValue</span>:number)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ProgrammerCalculator.digits.indexOf(digit)&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> currentValue*<span class="keyword">this</span>.base + ProgrammerCalculator.digits.indexOf(digit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//export the new extend calculator as Calculator</span></span><br><span class="line"><span class="keyword">export</span> &#123; ProgrammerCalcaulator <span class="keyword">as</span> Calculator&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//also, export the helper function</span></span><br><span class="line"><span class="keyword">export</span> &#123; test &#125; <span class="keyword">from</span> <span class="string">"./Calculator"</span>;</span><br></pre></td></tr></table></figure></p><p>新的ProgrammerCalculator模块导出的API与原先的Calculator模块很相似, 但却没有改变原模块里的对象.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//testProgrammerCalculator.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123;Calculator, test&#125; <span class="keyword">from</span> <span class="string">'./ProgrammerCalculator'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c=<span class="keyword">new</span> Calculator(<span class="number">2</span>);</span><br><span class="line">test(c, <span class="string">"001+010="</span>); <span class="comment">//3</span></span><br></pre></td></tr></table></figure></p><h3 id="模块里不要使用命名空间"><a href="#模块里不要使用命名空间" class="headerlink" title="模块里不要使用命名空间"></a>模块里不要使用命名空间</h3><p>当初次进入给予模块的开发模式时,可能总会控制不住要导出包裹在一个命名空间里. 模块具有其自己的作用域, 并且只有导出的声明才会在模块外部课件. </p><p>在组织方面, 命名空间对于在全局作用域内对逻辑上相关的对象和类型进行分组是很便利的, 例如C#中,从System.Collections里找到所有的集合的类型. 通过将类型有层次地在组织在命名空间里, 可以方便用户找到与使用那些类型. 然而,模块本身已经存在于文件系统之中, 这是必须的. 我们必须通过路径和文件名找到它们. 这已经提供了一种逻辑上的组织形式, 我们可以创建/collectios/generic/文件夹,吧相应模块放在这里.</p><p>命名空间对解决痊愈作用域里的命名冲突来说是很重要的. 如,可以有一个<code>My.Application.Customer.AddForm</code>和<code>My.Application.Order.AddForm</code>– 两个类型的名字相同,但命名空间不同. 然而,这对于模块来说却不是一个问题. 在一个模块里,没有理由两个对象拥有同一个名字. 从模块的使用角度来说, 使用者会跳出他们用来引用模块的名字, 所以也没有理由发生重名的情况.</p><blockquote><p>更多关于模块和名King空间爱你的资料查看<a href="https://www.tslang.cn/docs/handbook/namespaces-and-modules.html" target="_blank" rel="noopener">命名空间和模块</a></p></blockquote><h3 id="危险信号"><a href="#危险信号" class="headerlink" title="危险信号"></a>危险信号</h3><p>以下为模块结构上的危险信号. 重新检查以确保你没有在对模块使用命名空间:</p><ul><li>文件的顶层声明是export namespace Foo {} (删除Foo并把所有内容向上层移动一层)</li><li>文件只有一个export class 或 export function(考虑使用 export default)</li><li>多个文件的顶层具有同样的export namespace Foo{ (不要以为这些会合并到一个Foo中!)}</li></ul><p>The End!</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;关于术语的一点说明:&lt;/strong&gt; 请务必注意一点, TypeScript 1.5里术语已经发生了变化. “内部模块”现在称作”命名空间”. “外部模块”闲杂简称”模块”. 这是为了与ECMAScript 2015里的术语保持一致(也就是说 moduele X{ 相当于现在推荐的写法 namespace X{) &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;从ECMAScript 2015开始, javascript引入了模块的概念. Typescript也沿用了这个概念.&lt;/p&gt;
&lt;p&gt;模块在其自身的作用域里执行,而不是全局作用域里; 这意味着定义在一个模块里的变量,函数,类等等在模块外部是不可见的, 除非明确地私用 &lt;a href=&quot;https://www.tslang.cn/docs/handbook/modules.html#export&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;export&lt;/a&gt;之一导出它们. 相反, 如果想使用其它模块导出的变量,函数,类,接口等的时候, 你必须导入它们, 可以使用 &lt;a href=&quot;https://www.tslang.cn/docs/handbook/modules.html#import&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;import&lt;/a&gt;形式之一&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="https://xiaoxiaocoder.github.io/categories/programming/"/>
    
      <category term="javascript" scheme="https://xiaoxiaocoder.github.io/categories/programming/javascript/"/>
    
      <category term="typescript" scheme="https://xiaoxiaocoder.github.io/categories/programming/javascript/typescript/"/>
    
    
      <category term="typescript" scheme="https://xiaoxiaocoder.github.io/tags/typescript/"/>
    
      <category term="modules" scheme="https://xiaoxiaocoder.github.io/tags/modules/"/>
    
  </entry>
  
  <entry>
    <title>[TypeScript 10]手册指南: 迭代器和生成器</title>
    <link href="https://xiaoxiaocoder.github.io/programming/javascript/typescript/2017-08-19-typescript-10-iterators-and-generators.html"/>
    <id>https://xiaoxiaocoder.github.io/programming/javascript/typescript/2017-08-19-typescript-10-iterators-and-generators.html</id>
    <published>2017-08-19T14:49:35.000Z</published>
    <updated>2017-12-09T06:32:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="可迭代性"><a href="#可迭代性" class="headerlink" title="可迭代性"></a>可迭代性</h2><p>当一个对象实现了Symbol.iterator属性时,我们认为它是可迭代的. 一些内置的类型Array, Map, Set, String, Int32Array, Unit32Array等都已经实现了各自的Symbol.iteraotr. 对象上的Symbol.iterator函数负责返回供迭代的值.</p><h3 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h3><p>for..of会遍历可迭代的对象, 调用对象上的Symbol.iterator方法. 下面的数组上使用for..of的简单例子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someArray = [<span class="number">1</span>,<span class="string">"string"</span>,<span class="literal">false</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> entery <span class="keyword">of</span> someArray)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(entry); <span class="comment">// 1, "string", false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="for-of-vs-for-in"><a href="#for-of-vs-for-in" class="headerlink" title="for..of vs for..in"></a>for..of vs for..in</h3><ul><li><p>for..of和for..in均可迭代一个列表;但是用于迭代的值却不同. for..in迭代的对象的键的列表,而for..of则迭代对象的键对应的值.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list=[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> list)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// "0","1","2"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> list)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">//"4","5","6"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>另一个区别是for..in可以操作任何对象;它提供了查看对象属性的一种方法. 但是for..of关注于迭代对象的值. 内置对象Map和Set已经实现了Symbol.iterator方法. 让我们可以访问它们保存的值.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pets= <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">"cat"</span>,<span class="string">"dog"</span>,<span class="string">"hamster"</span>]);</span><br><span class="line">pets[<span class="string">"species"</span>]= <span class="string">"mammals"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> pet <span class="keyword">in</span> pets)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(pet);  <span class="comment">//"species"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> pet <span class="keyword">of</span> pets)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(pet); <span class="comment">// cat,dog,hamster</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>代码生成</strong><br><em>目标为ES5 和 ES3</em><br>当生成目标ES5或ES3, 迭代器只允许在Array类型上使用. 在非数组值上只用for..of语句会得到一个错误, 就算这些费数组值已经实现了Symbol.iterator属性.</p><p>编译器会生成一个简单的for循环作为for..of循环.比如:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> num <span class="keyword">of</span> numbers)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成的代码:</span></span><br><span class="line"><span class="keyword">var</span> numbers=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> _i=<span class="number">0</span>,len=numbers.length;_i&lt;len;_i++&gt;)&#123;</span><br><span class="line">    <span class="keyword">var</span> num= numbers[_i];</span><br><span class="line">    <span class="built_in">console</span>.log(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>目标为ECMAScript 2015或更高</em><br>当目标为兼容ECMAScript 2015的引擎时,编译器会生成相应引擎的for..of内置迭代器实现方式.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;可迭代性&quot;&gt;&lt;a href=&quot;#可迭代性&quot; class=&quot;headerlink&quot; title=&quot;可迭代性&quot;&gt;&lt;/a&gt;可迭代性&lt;/h2&gt;&lt;p&gt;当一个对象实现了Symbol.iterator属性时,我们认为它是可迭代的. 一些内置的类型Array, Map, Set, String, Int32Array, Unit32Array等都已经实现了各自的Symbol.iteraotr. 对象上的Symbol.iterator函数负责返回供迭代的值.&lt;/p&gt;
&lt;h3 id=&quot;for…of&quot;&gt;&lt;a href=&quot;#for…of&quot; class=&quot;headerlink&quot; title=&quot;for…of&quot;&gt;&lt;/a&gt;for…of&lt;/h3&gt;&lt;p&gt;for..of会遍历可迭代的对象, 调用对象上的Symbol.iterator方法. 下面的数组上使用for..of的简单例子:&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; someArray = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;string&quot;&lt;/span&gt;,&lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; entery &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; someArray)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(entry); &lt;span class=&quot;comment&quot;&gt;// 1, &quot;string&quot;, false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="https://xiaoxiaocoder.github.io/categories/programming/"/>
    
      <category term="javascript" scheme="https://xiaoxiaocoder.github.io/categories/programming/javascript/"/>
    
      <category term="typescript" scheme="https://xiaoxiaocoder.github.io/categories/programming/javascript/typescript/"/>
    
    
      <category term="typescript" scheme="https://xiaoxiaocoder.github.io/tags/typescript/"/>
    
      <category term="iterator" scheme="https://xiaoxiaocoder.github.io/tags/iterator/"/>
    
      <category term="generator" scheme="https://xiaoxiaocoder.github.io/tags/generator/"/>
    
  </entry>
  
  <entry>
    <title>[TypeScript 09]手册指南: Symbols</title>
    <link href="https://xiaoxiaocoder.github.io/programming/javascript/typescript/2017-08-19-typescript-09-symbols.html"/>
    <id>https://xiaoxiaocoder.github.io/programming/javascript/typescript/2017-08-19-typescript-09-symbols.html</id>
    <published>2017-08-19T14:27:47.000Z</published>
    <updated>2017-12-09T06:32:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>自ECMAScript 2015起, symbol称为了一种新的原生类型, 就像number和string一样.</p><p>symbol类型的值是通过Symbol构造函数创建的.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym1= <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">let</span> sym2= <span class="built_in">Symbol</span>(<span class="string">'key'</span>); <span class="comment">// 可选的字符串key</span></span><br></pre></td></tr></table></figure></p><p>Symbols是不可改变且唯一的.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym2= <span class="built_in">Symbol</span>(<span class="string">'key'</span>);</span><br><span class="line"><span class="keyword">let</span> sym3= <span class="built_in">Symbol</span>(<span class="string">'key'</span>);</span><br><span class="line"></span><br><span class="line">sym2 ==sym3; <span class="comment">//false, symbols 是唯一的.</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p>像字符串一样, symbols也可以被用作对象属性的键.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym= <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj =&#123;</span><br><span class="line">    [sym]:<span class="string">"value"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj[sym]); <span class="comment">///"value"</span></span><br></pre></td></tr></table></figure></p><p>Symbols也可以与计算出的属性名声明结合起来声明对象的属性和类成员.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getClassNameSymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    [getClassNameSymbol]()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"C"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c= <span class="keyword">new</span> C();</span><br><span class="line"><span class="keyword">let</span> className=c[getClassNameSymbol](); <span class="comment">//c</span></span><br></pre></td></tr></table></figure></p><h2 id="众所周知的Symbols"><a href="#众所周知的Symbols" class="headerlink" title="众所周知的Symbols"></a>众所周知的Symbols</h2><p>除了用户定义的symbols, 还有一些已经众所周知的内置symbols. 内置symbols用来表示语言内部的行为.<br>以下为这些symbols的列表:</p><ul><li>Symbol.hasInstance 方法,会被instanceof运算符调用. 构造器对象用来识别一个对象是否是其实例.</li><li>Symbol.isContactSpreadable 布尔值,表示当一个对象上调用Array.prototype.contact时,这个对象的数组元素是否可以展开.</li><li>Symbol.iterator 方法,被for-of语句调用. 返回对象的默认迭代器.</li><li>Symbol.match 方法, 被String.prototype.match调用. 正则表达式用来匹配字符串.</li><li>Symbol.replace  方法,被String.prototype.replace调用. 正则表达式用来替换字符串中匹配的子串.</li><li>Symbol.search   方法,被String.prototype.search调用. 正则表达式返回被匹配部分在字符串中的索引.</li><li>Symbol.species  函数值,为一个构造函数. 用来创建派生对象.</li><li>Symbol.split    方法,被String.prototype.split调用. 正则表达式用来分割字符串.</li><li>Symbol.toPrimitive  方法,被ToPrimitive抽象操作调用. 把对象转换为相应的原始值.</li><li>Symbol.toStringTag  方法,被内置方法Object.prototype.toString调用. 返回创建对象时默认的字符串描述.</li><li>Symbol.unscopeables 对象,它自己拥有的属性会被with作用域排除在外.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;自ECMAScript 2015起, symbol称为了一种新的原生类型, 就像number和string一样.&lt;/p&gt;
&lt;p&gt;symbol类型的值是通过Symbol构造函数创建的.&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; sym1= &lt;span class=&quot;built_in&quot;&gt;Symbol&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; sym2= &lt;span class=&quot;built_in&quot;&gt;Symbol&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;key&#39;&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// 可选的字符串key&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Symbols是不可改变且唯一的.&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; sym2= &lt;span class=&quot;built_in&quot;&gt;Symbol&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;key&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; sym3= &lt;span class=&quot;built_in&quot;&gt;Symbol&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;key&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sym2 ==sym3; &lt;span class=&quot;comment&quot;&gt;//false, symbols 是唯一的.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="https://xiaoxiaocoder.github.io/categories/programming/"/>
    
      <category term="javascript" scheme="https://xiaoxiaocoder.github.io/categories/programming/javascript/"/>
    
      <category term="typescript" scheme="https://xiaoxiaocoder.github.io/categories/programming/javascript/typescript/"/>
    
    
      <category term="typescript" scheme="https://xiaoxiaocoder.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记</title>
    <link href="https://xiaoxiaocoder.github.io/programming/javascript/reactjs/2017-08-12-reactjs-started.html"/>
    <id>https://xiaoxiaocoder.github.io/programming/javascript/reactjs/2017-08-12-reactjs-started.html</id>
    <published>2017-08-12T08:08:25.000Z</published>
    <updated>2017-12-09T06:32:33.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../../assets/imgs/blogImg/react-logo.png" alt="reactjs">  <a href="https://facebook.github.io/react/" target="_blank" rel="noopener">official site</a> | <a href="http://www.runoob.com/react/react-tutorial.html" target="_blank" rel="noopener">chinese site</a></p><ul><li>React是一个用于构建用户界面的Javascript库.</li><li>React主要用于构建UI,很多人认为React是MVC中的V(视图)</li><li>React起源于Facebook的内部项目,用来架设Instagram网站,并于2013年5月开源</li><li>React拥有较高的性能,代码逻辑非常简单,越来越多的人已经开始关注和使用它.</li></ul><a id="more"></a><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><h3 id="React特点"><a href="#React特点" class="headerlink" title="React特点"></a>React特点</h3><ol><li>声明式设计- React采用声明式范式,可以轻松描述应用.</li><li>高效 - React通过对DOM的模拟, 最大限度的减少与DOM的交互</li><li>灵活 - React可以与已知的库或框架很好地配合</li><li>JSX - JSX 是Javascript语法的扩展. React开发并不一定使用JSX, 但建议使用</li><li>组件 - 通过React构建组件, 使得代码更加容易得到复用,能够很好的应用在大项目中的开发中.</li><li>单向响应的数据流 - React实现了单向响应的数据流, 从而减少了重复代码,这也是它为什么比传统数据绑定更简单.</li></ol><h3 id="需要具备的基础"><a href="#需要具备的基础" class="headerlink" title="需要具备的基础"></a>需要具备的基础</h3><ul><li>HTML5</li><li>CSS</li><li>Javascript</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">ReactDOM.render(<span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, WorldM<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>,document.getElementById('example'));</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="React-安装"><a href="#React-安装" class="headerlink" title="React 安装"></a>React 安装</h2><p>示例版本15.4.2,可在官网下载或直接使用BooCDN的React CDN库. 地址如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://cdn.bootcss.com/react/15.4.2/react.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script src=<span class="string">"https://cdn.bootcss.com/react/15.4.2/react-dom.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script src=<span class="string">"https://cdn.bootcss.com/babel-standalone/6.22.1/babel.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>实例<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello React<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/react/15.4.2/react.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/react/15.4.2/react-dom.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/babel-standalone/6.22.1/babel.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"> ReactDOM.render(</span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, React<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>,</span></span><br><span class="line"><span class="javascript">     <span class="built_in">document</span>.getElemntById(<span class="string">'example'</span>)</span></span><br><span class="line"><span class="undefined"> );</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>实例解析:</p><ul><li>react.min.js React的核心库</li><li>react-dom.min.js 提供与DOM相关的功能</li><li>babel.min.js Babel可以将ES6代码转换为ES5代码, 这样我们就能在目前不支持ES6浏览器上执行React代码. Babel内嵌了对JSX的支持. 通过将Babel和babel-sublime包(package)一同使用可以将源码的语法渲染上升到一个全新的水平.<blockquote><p>注意: 如果我们需要使用JSX, 则将&lt; script&gt;标签的type属性设置为text/babel.</p></blockquote></li></ul><h3 id="通过npm使用React"><a href="#通过npm使用React" class="headerlink" title="通过npm使用React"></a>通过npm使用React</h3><p>建议在React中使用CommonJS模块系统. 比如 browserify 或webpack.<br>npm 小tips<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></p><p>这样就可以使用cnpm命令来安装模块了<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install [name]</span><br></pre></td></tr></table></figure></p><p>更多信息: <a href="http://npm.taobao.org" target="_blank" rel="noopener">http://npm.taobao.org</a></p><h3 id="使用create-react-app快速构建React开发环境"><a href="#使用create-react-app快速构建React开发环境" class="headerlink" title="使用create-react-app快速构建React开发环境"></a>使用create-react-app快速构建React开发环境</h3><p>create-react-app是来自于Facebook, 通过该命令我们无需设置就能快速构建React开发环境.<br>create-react-app自动创建的项目是给予Webpack + ES 6<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g create-react-app</span><br><span class="line">create-react-app my-app</span><br><span class="line">cd my-app</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure></p><h2 id="React-JSX"><a href="#React-JSX" class="headerlink" title="React JSX"></a>React JSX</h2><p>React使用JSX来替代常规的Javascript.<br>JSX是一个看起来很像XML的javascript语法扩展.<br>我们不需要一定使用JSX, 但它有以下优点:</p><ul><li>JSX执行更快,因为它在便以Javascript代码后进行了优化</li><li>它是类型安全的,在比那一过程中就能发现错误.</li><li>使用JSX编写模板更加简单快捷.</li></ul><h3 id="使用JSX"><a href="#使用JSX" class="headerlink" title="使用JSX"></a>使用JSX</h3><p>JSX看起来类似HTMl, 我们可以看下如下实例:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReacDOM.render(</span><br><span class="line">    &lt;h1&gt; Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>我们可以在以上代码中嵌套多个HTMl标签, 需要使用一个div元素包裹它. 实例中的p元素添加了自动以属性data-myattribute, 添加自定义属性需要使用data- 前缀.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;菜鸟教程&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;h2&gt;欢迎学习&lt;/</span>h2&gt;</span><br><span class="line">    &lt;p my-attribute=<span class="string">"somevalue"</span>&gt; what a awesome javascript libary!<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;,</span></span><br><span class="line"><span class="regexp">    document.getElementById('example')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure></p><h4 id="独立文件"><a href="#独立文件" class="headerlink" title="独立文件"></a>独立文件</h4><p>你的React JSX代码可以放在一个独立文件上, 例如我们创建一个helloworld_react.js 文件. 代码如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后在HTMl文件中引入该js文件</span></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=<span class="string">"example"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;script src=<span class="string">"helloworld_react.js"</span> type=<span class="string">"text/babel"</span>&gt;</span><br></pre></td></tr></table></figure></p><h3 id="javascript-表达式"><a href="#javascript-表达式" class="headerlink" title="javascript 表达式"></a>javascript 表达式</h3><p>我们可以JSX中使用Javascript表达式. 表达式卸载花括号{}中. 实例如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;&#123;<span class="number">1</span>+<span class="number">1</span>&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">       &#123;/</span>*</span><br><span class="line">       <span class="number">1.</span> 注释要写在花括号 &#123;<span class="comment">/*  * / &#125;中</span></span><br><span class="line"><span class="comment">       2. 在JSX中不能使用 if else语句,但可以使用conditional(三元)表达式来替代. 以下实例中如果变量i 等于1浏览器将输入true. 如果修改i的值, 则会输出false-</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">       &#125; </span><br><span class="line">        &lt;h2&gt;&#123;i==<span class="number">1</span>?<span class="string">"true"</span>:<span class="string">"false"</span>&#125;&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><p>React推荐使用内联样式. 我们可以使用cameCase语法来设置内联样式. React会在指定元素数字后自动添加px. 以下实例为为h1元素添加myStyle内联样式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myStyle=&#123;</span><br><span class="line">    fontSize:<span class="number">100</span>,</span><br><span class="line">    color:#ff00000</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;h1 style=&#123;myStyle&#125;&gt; Hello &lt;<span class="regexp">/h1&gt;,</span></span><br><span class="line"><span class="regexp">    document.getElementById('example')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>JSX 允许在模板中插入数组, 数组会自动展开所有成员:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr =[</span><br><span class="line">    &lt;h1&gt;xx教程&lt;<span class="regexp">/h1&gt;,</span></span><br><span class="line"><span class="regexp">    &lt;h2&gt;学习....&lt;h2&gt;</span></span><br><span class="line"><span class="regexp">];</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">    &lt;h1&gt;&#123;arr&#125;&lt;/</span>h1&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><h3 id="HTML标签-vs-React组件"><a href="#HTML标签-vs-React组件" class="headerlink" title="HTML标签 vs React组件"></a>HTML标签 vs React组件</h3><p>React可以渲染HTMl标签(strings) 或 React组件(Classes).<br>要渲染HTMl标签,只需要JSX里使用小写字母的标签名.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myDivElement =<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"foo"</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">ReactDOM.render(myDivElement,document.getElementById('example'));</span></span><br></pre></td></tr></table></figure></p><p>要渲染React组件, 只需创建一个大写的字母开头的本地变量<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyComponent= React.createClass(&#123;<span class="comment">/*....*/</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> myElement=<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">someProperty</span>=<span class="string">&#123;true&#125;</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">ReactDOM.render(myElement,document.getElementById('example'));</span></span><br></pre></td></tr></table></figure></p><p>React的JSX使用大,小写的约束来区分本地逐渐的类和html标签.</p><blockquote><p>注意: 由于JSX就是javascript. 一些标识符像class和for不建议作XML属性名. 作为代替, ReactDOM使用className 和 htmlFor来做对应的属性.</p></blockquote><h2 id="React组件"><a href="#React组件" class="headerlink" title="React组件"></a>React组件</h2><p>HelloMessage组件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> HelloMessage =React.createClass(&#123;</span><br><span class="line">    render:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;h1&gt;Hello world!&lt;h1&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;HelloMessage /&gt;,</span><br><span class="line">    document.getElementById('example')</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>实例解析:</p><ul><li>React.createClass 方法用于生成一个组件类HelloMessage.</li><li><hellomessage> 实例组件类并输出信息.<blockquote><p>  注意:原声HTML元素名以小写字母开头, 而自定义的React类名以大写字母开头,比如HelloMessage不能写成helloMessage. 除此之外还需要注意组件类只能包含一个顶层标签. 否则也会报错.</p></blockquote></hellomessage></li></ul><p>如果需要向组件传递参数,可以使用<strong>this.props</strong>对象. 实例如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> HelloMessage=React.createClass(&#123;</span><br><span class="line">    render:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        retrun &lt;h1&gt;Hello &#123;<span class="keyword">this</span>.props.name&#125; &lt;<span class="regexp">/h1&gt;;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">    &lt;HelloMessage name="Runoob" /</span>&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><blockquote><p>再添加属性时,class属性需要写成className, for属性需要写成htmlFor. 这是因为class和for是JavaScript保留字.</p></blockquote><h3 id="复合组件"><a href="#复合组件" class="headerlink" title="复合组件"></a>复合组件</h3><p>我们可以通过创建多个组件来合成一个组件, 即把组件的不同功能点进行分离.<br>以下是我们事先了输出网站名字和网址的组件:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> WebSite= React.createClass(&#123;</span><br><span class="line">    render:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;Name name=&#123;<span class="keyword">this</span>.props.name&#125; /&gt;</span><br><span class="line">                &lt;Link site=&#123;<span class="keyword">this</span>.props.site&#125; /&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">var Name=React.createClass(&#123;</span></span><br><span class="line"><span class="regexp">    render:function()&#123;</span></span><br><span class="line"><span class="regexp">        return (</span></span><br><span class="line"><span class="regexp">            &lt;h1&gt; &#123;this.props.name&#125; &lt;/</span>h1&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Link = React.createClass(&#123;</span><br><span class="line">    render:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;a href=<span class="string">"this.props.site"</span>&gt;</span><br><span class="line">            &#123;<span class="keyword">this</span>.props.site&#125;</span><br><span class="line">            &lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">React.render(</span></span><br><span class="line"><span class="regexp">    &lt;WebSite name="xx" site="http:/</span><span class="regexp">/xxx"&gt;,</span></span><br><span class="line"><span class="regexp">    document.getElementById('example')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure></p><p>实例中WebSite组件使用了Name和Link组件来输出对应的信息. 也就是说WebSite拥有Name和Link的实例.</p><p><strong>细节: ReactDOM.render(&lt;组件名 /&gt;); 组件名是单标签需要以’/‘来闭合标签</strong></p><h3 id="React-State-状态"><a href="#React-State-状态" class="headerlink" title="React State(状态)"></a>React State(状态)</h3><p>React把组件看成一个状态机(State Machines). 通过与yoghurt的交互,实现不同状态. 然后渲染UI, 让用户界面和数据保持一致.<br>React里, 只需要更新组件的state, 然后根据新的state重新渲染用户界面(不要操作DOM).</p><p>以下实例中创建了LinkButton组件, getInitialState方法用于定义初始化状态,也就是一个对象, 这个对象可以通过this.state属性读取. 当用户点击组件,导致状态变化, this.setState方法就是修改状态值, 每次修改以后,自动调用this.render方法, 再次渲染组件.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> LinkButton =React.createClass(&#123;</span><br><span class="line">    getInitialState:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">liked</span>:<span class="literal">false</span>&#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    handleClick:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">liked</span>: !<span class="keyword">this</span>.state.liked&#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    render:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> text=<span class="keyword">this</span>.state.liked? <span class="string">"yes"</span> : <span class="string">"no"</span>;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;p onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">            Click Me to change the state.</span><br><span class="line">            Do you like me? &#123;text&#125;.</span><br><span class="line">            &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">RenderDOM.render(</span></span><br><span class="line"><span class="regexp">    &lt;LinkButton /</span>&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><h2 id="React-Props"><a href="#React-Props" class="headerlink" title="React Props"></a>React Props</h2><p>state和props主要的区别在于props是不可变的,而state可以根据与用户交互来改变. 这就是为什么有些容器组件需要定义state来更新和修改数据. 而子组件只能通过props来传递数据.</p><h3 id="使用Props"><a href="#使用Props" class="headerlink" title="使用Props"></a>使用Props</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> HelloMessage = React.createClass(&#123;</span><br><span class="line">    render:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span> Hello &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">HelloMessage</span> <span class="attr">name</span>=<span class="string">"ruboob"</span> /&gt;</span>),document.getELementById('example');</span></span><br></pre></td></tr></table></figure><p>实例中name属性通过this.props.name来获取.</p><h3 id="默认Props"><a href="#默认Props" class="headerlink" title="默认Props"></a>默认Props</h3><p>你可以通过getDefaultProps() 方法为props设置默认值.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> HelloMessage =React.createClass(&#123;</span><br><span class="line">    getDefaultProps:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            name: <span class="string">"andy"</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    render :<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span> Hello &#123;this.props.name&#125; <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;HelloMessage /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><h3 id="State和Props"><a href="#State和Props" class="headerlink" title="State和Props"></a>State和Props</h3><p>如何组合使用state和props. 我们可以在父组件中设置state,并通过在子组件上使用props将其传递到子组件上. 在render函数中,我们设置name和site来获取父组件传递过来的数据.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> WebSite =React.createClass(&#123;</span><br><span class="line">    getInitialState:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            name: <span class="string">"xxx"</span>,</span><br><span class="line">            site:<span class="string">"http://www.xxx.com"</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    render:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;Name name=&#123;<span class="keyword">this</span>.state.name&#125; /&gt;</span><br><span class="line">                &lt;Link site=&#123;<span class="keyword">this</span>.state.site&#125; /&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">var Name= React.createClass(&#123;</span></span><br><span class="line"><span class="regexp">    render: function()&#123;</span></span><br><span class="line"><span class="regexp">        return (</span></span><br><span class="line"><span class="regexp">            &lt;h1&gt; &#123;this.props.name&#125; &lt;/</span>h1&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Link =React.createClass(&#123;</span><br><span class="line">    render:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;a href=<span class="string">"&#123;this.props.site&#125;"</span>&gt;</span><br><span class="line">                &#123;<span class="keyword">this</span>.props.site&#125;</span><br><span class="line">            &lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">    &lt;WebSite /</span>&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><h3 id="Props验证"><a href="#Props验证" class="headerlink" title="Props验证"></a>Props验证</h3><p>Props验证使用propTypes, 它可以保证我们的应用组件被正确使用, React.PropTypes提供很多验证器(validator)来验证传入的数据是否有效. 当向props传入无效数据时,Javascript控制台会抛出警告.<br>以下创建一个MyTitle组件,属性title必须是字符串,非字符串类型会自动转换为字符串.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> title=<span class="string">"xxx"</span>;</span><br><span class="line"><span class="keyword">var</span> MyTitle=React.createClass(&#123;</span><br><span class="line">    propTypes:&#123;</span><br><span class="line">        title: React.PropTypes.string.isRequired</span><br><span class="line">    &#125;,</span><br><span class="line">    render:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span> &#123;this.props.title&#125; <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;MyTitle title=&#123;title&#125;/&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>更多验证器说明如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">React.createClass(&#123;</span><br><span class="line">  propTypes: &#123;</span><br><span class="line">    <span class="comment">// 可以声明 prop 为指定的 JS 基本数据类型，默认情况，这些数据是可选的</span></span><br><span class="line">   optionalArray: React.PropTypes.array,</span><br><span class="line">    optionalBool: React.PropTypes.bool,</span><br><span class="line">    optionalFunc: React.PropTypes.func,</span><br><span class="line">    optionalNumber: React.PropTypes.number,</span><br><span class="line">    optionalObject: React.PropTypes.object,</span><br><span class="line">    optionalString: React.PropTypes.string,</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 可以被渲染的对象 numbers, strings, elements 或 array</span></span><br><span class="line">    optionalNode: React.PropTypes.node,</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//  React 元素</span></span><br><span class="line">    optionalElement: React.PropTypes.element,</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 用 JS 的 instanceof 操作符声明 prop 为类的实例。</span></span><br><span class="line">    optionalMessage: React.PropTypes.instanceOf(Message),</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 用 enum 来限制 prop 只接受指定的值。</span></span><br><span class="line">    optionalEnum: React.PropTypes.oneOf([<span class="string">'News'</span>, <span class="string">'Photos'</span>]),</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 可以是多个对象类型中的一个</span></span><br><span class="line">    optionalUnion: React.PropTypes.oneOfType([</span><br><span class="line">      React.PropTypes.string,</span><br><span class="line">      React.PropTypes.number,</span><br><span class="line">      React.PropTypes.instanceOf(Message)</span><br><span class="line">    ]),</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 指定类型组成的数组</span></span><br><span class="line">    optionalArrayOf: React.PropTypes.arrayOf(React.PropTypes.number),</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 指定类型的属性构成的对象</span></span><br><span class="line">    optionalObjectOf: React.PropTypes.objectOf(React.PropTypes.number),</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 特定 shape 参数的对象</span></span><br><span class="line">    optionalObjectWithShape: React.PropTypes.shape(&#123;</span><br><span class="line">      color: React.PropTypes.string,</span><br><span class="line">      fontSize: React.PropTypes.number</span><br><span class="line">    &#125;),</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 任意类型加上 `isRequired` 来使 prop 不可空。</span></span><br><span class="line">    requiredFunc: React.PropTypes.func.isRequired,</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 不可空的任意类型</span></span><br><span class="line">    requiredAny: React.PropTypes.any.isRequired,</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 自定义验证器。如果验证失败需要返回一个 Error 对象。不要直接使用 `console.warn` 或抛异常，因为这样 `oneOfType` 会失效。</span></span><br><span class="line">    customProp: <span class="function"><span class="keyword">function</span>(<span class="params">props, propName, componentName</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="regexp">/matchme/</span>.test(props[propName])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Validation failed!'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="React-组件API"><a href="#React-组件API" class="headerlink" title="React 组件API"></a>React 组件API</h2><ul><li>设置状态: setState</li><li>替换状态: replaceState</li><li>设置属性: setProps</li><li>替换属性: replaceProps</li><li>强制更新: forceUpdate</li><li>获取DOM节点: findDOMNOde</li><li>判断组件挂在状态: isMounted</li></ul><h3 id="设置状态-setState"><a href="#设置状态-setState" class="headerlink" title="设置状态: setState"></a>设置状态: setState</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setState(object nextState[,<span class="function"><span class="keyword">function</span> <span class="title">callback</span>])</span></span><br></pre></td></tr></table></figure><p><strong>参数说明:</strong></p><ul><li>nextState: 将要设置的新状态,该状态会和当前的state合并</li><li>callback: 可选参数,回调函数. 将韩慧会在setState设置成功,且组件重新渲染后调用.<br>合并nextState和当前state, 并重新渲染组件. setState是React时间处理函数总和请求回调函数中触发UI更新的主要方法.<br><strong>关于setState</strong><br>不能再组件内部通过this.state修改状态, 因为该状态会咋调用setState()后被替换.<br>setState()并不会立即改变this.state, 而是创建了一个即将处理的state. setState()并不一定是同步的,为了提升性能React会批量执行state和DOM渲染.<br>setState()总是会触发一次组件重绘, 除非在shouldComponentUpdatet() 中实现了一些条件渲染逻辑.<br>实例<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Counter=React.createClass(&#123;</span><br><span class="line">    getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">clickCount</span>:<span class="number">0</span>&#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    handleClick:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(<span class="function"><span class="keyword">function</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">clickCount</span>: state.clickCount+<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    render:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;h2 onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;Click Me! The current Click Count:&#123;<span class="keyword">this</span>.state.clickCount&#125;&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;); </span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">    &lt;Counter /</span>&gt;,</span><br><span class="line">    dcument.getElementById(<span class="string">'example'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><h3 id="替换状态-replaceState"><a href="#替换状态-replaceState" class="headerlink" title="替换状态: replaceState"></a>替换状态: replaceState</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replaceState(object nextState[,<span class="function"><span class="keyword">function</span> <span class="title">callback</span>])</span></span><br></pre></td></tr></table></figure><ul><li>nextState: 将要设置的新状态,该状态会替换当前的state</li><li>callback: 可选参数,会地哦啊函数. 该函数会在replaceState设置成功,且组件重新渲染后调用.<br>replaceState() 方法与setState()类似,但是方法只会保留nextState中保留状态,原state不在nextState中的状态都会被删除.</li></ul><h3 id="设置属性-setProps"><a href="#设置属性-setProps" class="headerlink" title="设置属性: setProps"></a>设置属性: setProps</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setProps(object nextProps[,<span class="function"><span class="keyword">function</span> <span class="title">callback</span>])</span></span><br></pre></td></tr></table></figure><ul><li>nextProps: 将要设置的新属性,该状态会和当前的props合并</li><li>callback: 可选,回调. 该函数会在setProps设置成功,且组件重新渲染后调动.<br>设置组件属性,并重新渲染组件.<br>props相当于组件的数据流,它总是会从父组件向下传递所有的子组件中. 当和一个外部的Javascript应用集成时,我们可能会需要向组件船赌数据或通知React.render()组件需要重新渲染,可以使用setProps().<br>更新组件,我可以在节点上再次调用React.render(), 也可以通过setProps()方法改变组件属性,触发组件重新渲染.</li></ul><h3 id="替换属性-replaceProps"><a href="#替换属性-replaceProps" class="headerlink" title="替换属性: replaceProps"></a>替换属性: replaceProps</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replaceProps(object nextProps[,<span class="function"><span class="keyword">function</span> <span class="title">callback</span>])</span></span><br></pre></td></tr></table></figure><ul><li>nextProps: 将要设置的新属性,该属性会替换当前的props</li><li>callback: 可选,回到函数. 该函数会在replaceProps设置成功,<strong>且组件重新渲染后调用</strong><br>replaceProps()方法与setProps类似,但它会删除原有props</li></ul><h3 id="强制更新-forceUpdate"><a href="#强制更新-forceUpdate" class="headerlink" title="强制更新: forceUpdate"></a>强制更新: forceUpdate</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forceUpdate([<span class="function"><span class="keyword">function</span> <span class="title">callback</span>])</span></span><br></pre></td></tr></table></figure><ul><li>callback: 可选,回调. 该函数会在组件render()方法后调用.<br>forceUpdate()方法会使组件调动自身的render()方法重新渲染组件, 组件的子组件也会调用自己的render(). 但是,组件重新渲染时,依然会读取this.props和this.state,如果状态没有改变, 那么React只会更新DOM<br>forceUpdate()方法适用于this.props和this.state之外的组件重绘(如:修改了this.state后),通过该方法通知React需要调用render()<br>一般来说,应该尽量避免使用forceUpdate(), 而仅从this.props和this.state中读取状态并由React触发render()调用.</li></ul><h3 id="获取DOM节点-findDOMNode"><a href="#获取DOM节点-findDOMNode" class="headerlink" title="获取DOM节点: findDOMNode"></a>获取DOM节点: findDOMNode</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOMElement findDOMNode()</span><br></pre></td></tr></table></figure><p>返回值: DOM元素DOMElement<br>如果组件已经挂在到DOM中,该方法返回对应的本地浏览器DOM元素. 当render返回null或false时,this.fiDOMNode()也会返回null. 从DOM中读取值得时候, 该方法很有用. 如: 获取表单字段的值和做一些DOM操作.</p><h3 id="判断组件状态-isMounted"><a href="#判断组件状态-isMounted" class="headerlink" title="判断组件状态: isMounted"></a>判断组件状态: isMounted</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool isMounted()</span><br></pre></td></tr></table></figure><p>返回值: true 或false. 表示组件是否已经挂在到DOm中.<br>isMounted() 方法用于判断组件是否已经挂在到DOM中, 可以使用该方法保证了setState() 和 forceUpdate() 在异步场景下的调用不会出错.</p><h2 id="React组件生命周期"><a href="#React组件生命周期" class="headerlink" title="React组件生命周期"></a><a href="https://facebook.github.io/react/docs/react-component.html" target="_blank" rel="noopener">React组件生命周期</a></h2><p>组件生命周期可分为三个状态:</p><ul><li>Mounting: 已插入真实DOM</li><li>Updateing: 正在被重新渲染</li><li>Unmounting: 已移除真实DOM</li></ul><p>生命周期的方法:</p><ul><li>componentWillMount: 在渲染前调用, 在客户端也在服务端</li><li>componentDidMount: 在第一次渲染后调用,只在客户端. 之后组件已经生成了对应的DOM结构,可以通过this.getDOMNode()来进行访问. 如果你想和其他javascript框架一起使用,可以在这个方法中调用setTimeout, setInterval或者发送AJAX请求等操作(防止异步操作阻塞UI).</li><li>componentWillReceiveProps: 组件接收到一个新的prop时被调用. 这个方法在初始化render时不会被调用.</li><li>shouldComponentUpdate: 返回一个布尔值. 在组件接收到新的props或者state时被调用. 在初始化或者使用forceUpdate时不被调用. 可以在你确认不需要更新组件时使用.</li><li>componentWillUpdate: 在组件接收到新的props或者state但还没render时被调用. 在初始化时不会被调用.</li><li>componentDidUpdate: 在组件完成工薪后立即调用. 在初始化时不会被调用.</li><li>componentWillUnmount: 在组件从DOM中移除时立即被调用.</li></ul><p><a href="https://facebook.github.io/react/docs/react-component.html" target="_blank" rel="noopener">官网文档</a></p><p>以下实例在Hello组件加载后, 通过ComponentDidMount方法设置一个定时器,每隔100ms重新设置组件的透明度,并重新渲染<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Hello =React.createClass(&#123;</span><br><span class="line">    getInitialState:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            opacity:<span class="number">1.0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    componentDidMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.timer=setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> opacity=<span class="keyword">this</span>.state.opacity;</span><br><span class="line">            opacity-=<span class="number">0.5</span>;</span><br><span class="line">            <span class="keyword">if</span>(opacity&lt;<span class="number">0.1</span>)&#123;</span><br><span class="line">                opacity=<span class="number">1.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                opacity:opacity</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;.bind(<span class="keyword">this</span>),<span class="number">100</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    render:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div style=&#123; &#123;<span class="attr">opacity</span>: <span class="keyword">this</span>.state.opacity&#125;&#125;&gt;</span><br><span class="line">             Hello &#123;<span class="keyword">this</span>.props.name&#125;</span><br><span class="line">             &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.rendr(</span></span><br><span class="line"><span class="regexp">    &lt;Hello name="world"/</span>&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>以下实例初始化state, setNewnumber用于更新state. 所有生命周期在Content组件中.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Button =React.createClass(&#123;</span><br><span class="line">    getInitialState:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            data:<span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    setNewNumber:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">data</span>: <span class="keyword">this</span>.state.data+<span class="number">1</span>&#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    render:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="keyword">this</span>.setNewNumber&#125;&gt;INCREMENT&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">                &lt;Content myNumber=&#123;this.state.data&#125;&gt;&lt;/</span>Content&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">var Content= React.createClass(&#123;</span></span><br><span class="line"><span class="regexp">    componentWillMount:function()&#123;</span></span><br><span class="line"><span class="regexp">        console.log('Component Will Mount!');</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    componentDidMount:function()&#123;</span></span><br><span class="line"><span class="regexp">        console.log('Component Did Mount');</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    componentWillReceiveProps:function(newProps)&#123;</span></span><br><span class="line"><span class="regexp">        console.log('Component will receive props!')</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    shouldComponentUpdate:function(newProps,newState)&#123;</span></span><br><span class="line"><span class="regexp">        return true;</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    componentWillUpdate:function(newProps,newStates)&#123;</span></span><br><span class="line"><span class="regexp">        console.log('Component will update');</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    componentDidUpdate:function(prevProps,prevState)&#123;</span></span><br><span class="line"><span class="regexp">        console.log('component did update');</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    componentWillUnmount:function()&#123;</span></span><br><span class="line"><span class="regexp">        console.log('component will unmount!');</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    render:function()&#123;</span></span><br><span class="line"><span class="regexp">        return (</span></span><br><span class="line"><span class="regexp">            &lt;div&gt;</span></span><br><span class="line"><span class="regexp">                &lt;h3&gt; &#123;this.props.myNUmber&#125; &lt;/</span>h3&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Button/</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;,</span></span><br><span class="line"><span class="regexp">    document.getElementById('example')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure></p><h2 id="React-AJAX"><a href="#React-AJAX" class="headerlink" title="React AJAX"></a>React AJAX</h2><p>React组件的数据可以通过componentDidMount方法中的Ajax来获取. 当从 当从服务端获取数据后可以将数据存储在state中,再用this.setState方法重新渲染UI.<br>当使用异步加载数据时,在组件卸载前使用componentWillUnmount来取消未完成的请求.<br>以下演示虎丘github用户最近gist共享描述:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> UserGist= React.createClass(&#123;</span><br><span class="line">    getInitialState:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            username:<span class="string">''</span>,</span><br><span class="line">            lastGistUrl:<span class="string">''</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    componentDidMount:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serverRequest=$.get(<span class="keyword">this</span>.props.source,<span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> lastGist= result[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                username: LastGist.owner.login,</span><br><span class="line">                lastGistUrl: lastGist.html_url</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;.bind(<span class="keyword">this</span>))</span><br><span class="line">    &#125;,</span><br><span class="line">    componentWillUnmount:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serverRequest.abort();</span><br><span class="line">    &#125;,</span><br><span class="line">    render:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &#123;<span class="keyword">this</span>.state.username&#125; the lates Gist url: </span><br><span class="line">                &lt;a href=&#123;<span class="keyword">this</span>.state.lastGistUrl&#125;&gt; &#123;<span class="keyword">this</span>.state.lastGistUrl&#125; &lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">    &lt;UserGist source="https:/</span><span class="regexp">/api.github.com/u</span>sers/octocat/gists<span class="string">"&gt;,</span></span><br><span class="line"><span class="string">    mountNode</span></span><br><span class="line"><span class="string">);</span></span><br></pre></td></tr></table></figure></p><p>以上代码使用jQuery完成Ajax请求.</p><h2 id="React-表单与事件"><a href="#React-表单与事件" class="headerlink" title="React 表单与事件"></a>React 表单与事件</h2><p>一个简单的示例:<br>在实例中我们设置了输入框input值 value ={this.state.data}. 在输入框值发生变化时我们可以更新state. 我们可以使用onChange事件来监听input的变化,并修改state.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> HelloMessage= React.createClass(&#123;</span><br><span class="line">    getInitialState:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">value</span>:<span class="string">'hello world'</span>&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    handleChange:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>:event.target.value&#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    render:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> value=<span class="keyword">this</span>.state.value;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line">                    &lt;input type="text" value=&#123;value&#125; onChange=&#123;this.handleChange&#125;/&gt;</span><br><span class="line">                    &lt;h4&gt;&#123;value&#125;&lt;/h4&gt;</span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">&#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">ReactDOM.render(</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">HelloMessage</span> /&gt;</span>,</span></span><br><span class="line"><span class="xml">    document.getElementById('example')</span></span><br><span class="line"><span class="xml">);</span></span><br></pre></td></tr></table></figure></p><p>实例2<br>以下实例压实如何在子组上使用表单. onChange方法将触发state的更新并将更新的值传递到子组件的输入框value来重新渲染界面.<br>需要在父组件通过创建事件句柄(handleChange),并作为prop(updateStateProp)传递到子组件上.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Content= React.createClass(&#123;</span><br><span class="line">    render:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line">                &lt;input type="text" value=&#123;this.props.myDataProp&#125;</span><br><span class="line">                onChange=&#123;this.props.updateStateProp&#125;</span><br><span class="line">                /&gt;</span><br><span class="line">                &lt;h4&gt; &#123;this.props.myDataProp&#125;&lt;/h4&gt;</span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">&#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">var HelloMessage =React.createClass(&#123;</span></span><br><span class="line"><span class="xml">    getInitialState:function()&#123;</span></span><br><span class="line"><span class="xml">        return &#123;value:"hello"&#125;</span></span><br><span class="line"><span class="xml">    &#125;,</span></span><br><span class="line"><span class="xml">    handleChange:function(event)&#123;</span></span><br><span class="line"><span class="xml">        this.setState(value:event.target.value)</span></span><br><span class="line"><span class="xml">    &#125;,</span></span><br><span class="line"><span class="xml">    render:function()&#123;</span></span><br><span class="line"><span class="xml">        var value= this.state.value;</span></span><br><span class="line">        return &lt;div&gt;</span><br><span class="line">                &lt;Content myDataProp=&#123;value&#125;</span><br><span class="line">                    updateStateProp=&#123;this.handleChange&#125;</span><br><span class="line">                &gt;&lt;/Content&gt;</span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">&#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">ReactDOM.render(</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">HelloMessage</span> /&gt;</span>,</span></span><br><span class="line"><span class="xml">    document.getElementById('example')</span></span><br><span class="line"><span class="xml">)</span></span><br></pre></td></tr></table></figure></p><h3 id="React-事件"><a href="#React-事件" class="headerlink" title="React 事件"></a>React 事件</h3><p>以下实例演示通过onClick事件来修改数据<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> HelloMessage= React.createClass(&#123;</span><br><span class="line">    getInitialState:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">value</span>:<span class="string">'hello'</span>&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    handleChange:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>:<span class="string">'xxx'</span>&#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    render:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> value=<span class="keyword">this</span>.state.value;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleChange&#125;</span>&gt;</span>Click me <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">                   <span class="tag">&lt;<span class="name">h4</span>&gt;</span>&#123;value&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;HelloMessage /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>当你需要ongoing子组件中更新父组件state时,你需要在父组件通过创建事件句柄(handleChange),并作为prop(updateStateProp)传递到你的子组件上.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Content=React.createClass(&#123;</span><br><span class="line">    render:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.props.updateStateProp&#125;</span>&gt;</span>click <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>&#123;this.props.myDataProp&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;           </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> HelloMessage=React.createClass(&#123;</span><br><span class="line">    getInitialState:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">value</span>:<span class="string">'hello'</span>&#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    handleChange:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(value:<span class="string">"xxx"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    render:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> value=<span class="keyword">this</span>.state.value;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line">                &lt;Content myDataProp=&#123;value&#125;</span><br><span class="line">                 updateStateProp=&#123;this.handleChange&#125;</span><br><span class="line"><span class="xml">                &gt;<span class="tag">&lt;/<span class="name">Content</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;HelloMessage/&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><h2 id="React-Refs"><a href="#React-Refs" class="headerlink" title="React Refs"></a>React Refs</h2><p>React支持一种非常特殊的属性Ref, 你可以用来绑定到render()输出的任何组件上.<br>这个特殊的属性运去你引用render()返回的相应的支撑实例(backing instance). 这样就可以确保在任何时间总是拿到正确的实例.</p><p><strong>使用方法</strong><br>绑定一个ref属性到render返回值上.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input ref=<span class="string">"myInput"</span>&gt;</span><br></pre></td></tr></table></figure></p><p>在其他代码中,通过this.refs获取支撑实例:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> input=<span class="keyword">this</span>.refs.myInput;</span><br><span class="line"><span class="keyword">var</span> inputValue=input.value;</span><br><span class="line"><span class="keyword">var</span> inputRect=input.getBoundingClientRect();</span><br></pre></td></tr></table></figure></p><p><strong>完整实例</strong><br>你可以通过使用this来获取当前React组件,或使用ref来获取组件的引用.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyComponent=React.createClass(&#123;</span><br><span class="line">    handleClick:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//使用原生的DOM API获取焦点</span></span><br><span class="line">        <span class="keyword">this</span>.refs.myInput.focus();</span><br><span class="line">    &#125;,</span><br><span class="line">    render:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//当组件插入到DOM后,ref属性添加一个组件的引用用于到this.refs</span></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;input type=<span class="string">"text"</span> ref=<span class="string">"myInput"</span> /&gt;</span><br><span class="line">                &lt;input type=<span class="string">"button"</span> value=<span class="string">"click me to focus in"</span> onClick=&#123;<span class="keyword">this</span>.handleClick&#125;/&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">    &lt;MyComponent /</span>&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>实例中,我们获取了输入框的支撑的实例的引用,子点击按钮后输入框获取焦点.</p><p>我们也可以使用getDOMNode()方法获取DOM元素.</p><p>The End!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../../assets/imgs/blogImg/react-logo.png&quot; alt=&quot;reactjs&quot;&gt;  &lt;a href=&quot;https://facebook.github.io/react/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;official site&lt;/a&gt; | &lt;a href=&quot;http://www.runoob.com/react/react-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;chinese site&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;React是一个用于构建用户界面的Javascript库.&lt;/li&gt;
&lt;li&gt;React主要用于构建UI,很多人认为React是MVC中的V(视图)&lt;/li&gt;
&lt;li&gt;React起源于Facebook的内部项目,用来架设Instagram网站,并于2013年5月开源&lt;/li&gt;
&lt;li&gt;React拥有较高的性能,代码逻辑非常简单,越来越多的人已经开始关注和使用它.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="编程" scheme="https://xiaoxiaocoder.github.io/categories/programming/"/>
    
      <category term="javascript" scheme="https://xiaoxiaocoder.github.io/categories/programming/javascript/"/>
    
      <category term="reactjs" scheme="https://xiaoxiaocoder.github.io/categories/programming/javascript/reactjs/"/>
    
    
      <category term="reactjs" scheme="https://xiaoxiaocoder.github.io/tags/reactjs/"/>
    
  </entry>
  
  <entry>
    <title>[TypeScript 08]手册指南: 高级类型</title>
    <link href="https://xiaoxiaocoder.github.io/programming/javascript/typescript/2017-08-07-typescript-08-advanced-types.html"/>
    <id>https://xiaoxiaocoder.github.io/programming/javascript/typescript/2017-08-07-typescript-08-advanced-types.html</id>
    <published>2017-08-07T02:41:24.000Z</published>
    <updated>2017-12-09T06:32:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="交叉类型-intersection-types"><a href="#交叉类型-intersection-types" class="headerlink" title="交叉类型(intersection types)"></a>交叉类型(intersection types)</h2><p>交叉类型是将多个类型合并为一个类型. 这让我们可以把现有的多种类型叠加到一起为一种类型, 它包含了所需的所有类型的特性. 例如, Person &amp; Serializable &amp; Loggable 同时是Person 和 Serializable和Loggable. 就是说这个类型的对象同时拥有了这三种类型的成员.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>&lt;<span class="title">T</span>,<span class="title">U</span>&gt;(<span class="params">first:T,second:U</span>):<span class="title">T</span>&amp;<span class="title">U</span></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result=<span class="xml"><span class="tag">&lt;<span class="name">T</span> &amp; <span class="attr">U</span>&gt;</span>&#123;&#125;;</span></span><br><span class="line"><span class="xml">    for(let id in first)&#123;</span></span><br><span class="line">        (&lt;any&gt;result)[id]=(&lt;any&gt;first)[id];</span><br><span class="line">    &#125;</span><br><span class="line">    for(let id in second)&#123;</span><br><span class="line">        if(!result.hasOwnProperty(id))&#123;</span><br><span class="line">            (&lt;any&gt;result)[id]=(&lt;any&gt;second)[id];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return reuslt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">    constructor(public name:string)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">interface Loggable&#123;</span><br><span class="line">    log():void;</span><br><span class="line">&#125;</span><br><span class="line">class ConsoleLogger implements Loggable&#123;</span><br><span class="line">    log()&#123;</span><br><span class="line">        //...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var jim=extend(new Person('Jim'),new ConsoleLogger());</span><br><span class="line">var n=jim.name;</span><br><span class="line">jim.log();</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="联合类型-Union-Types"><a href="#联合类型-Union-Types" class="headerlink" title="联合类型(Union Types)"></a>联合类型(Union Types)</h2><p>联合类型与交叉类型很有关联, 但是使用上却完全不同. 偶尔会遇到这种情况,一个代码库希望传入number或string类型的参数. 如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Takes a string and adds "padding" to the left.</span></span><br><span class="line"><span class="comment">if 'padding' is a string, then 'padding' is appended to the left side.</span></span><br><span class="line"><span class="comment">if 'padding' is a number, then that number of spaces is added to the left side.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span>(<span class="params">value:string,padding:any</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> padding ==<span class="string">"number"</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>(padding+<span class="number">1</span>).join(<span class="string">" "</span>)+value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> padding ==<span class="string">"string"</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> padding+value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Excepted string or number, got '<span class="subst">$&#123;padding&#125;</span>'.`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">padLeft(<span class="string">"Hello world"</span>,<span class="number">4</span>) <span class="comment">//returns "    Hello world"</span></span><br></pre></td></tr></table></figure></p><p>padLeft存在一个问题, padding参数的类型指定成了any. 这就是说我们可以传入一个既不是number也不是string类型的参数, 但是TypeScript却不报错.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> indentedString =padLeft(<span class="string">'Hello world'</span>,<span class="literal">true</span>); <span class="comment">//编译阶段通过,运行时报错.</span></span><br></pre></td></tr></table></figure></p><p>在传统的面向对象语言里,我们可能会UI将这两宗类型抽象成有层级的类型. 这么做显然是非常清晰的, 但同时也存在了过渡设计. padLeft原始版本的好处之一是允许我们传入原始类型. 这样做的话使用起来既简单又方便. 如果我们就是想使用已经存在的函数的话, 这种新的方式就不适用了.<br>代替<strong>any</strong>, 我们可以使用联合类型作为<strong>padding</strong>的参数:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">takes a string and adds "padding" to the left.</span></span><br><span class="line"><span class="comment">if 'padding' is a string, then 'padding' is appended to the left side.</span></span><br><span class="line"><span class="comment">if 'padding' is a number, then that number of spaces is added to the left side.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span>(<span class="params">value:string, padding: string | number</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> indentedString =padLeft(<span class="string">"Hello world"</span>,<span class="literal">true</span>); <span class="comment">//errors during compilation</span></span><br></pre></td></tr></table></figure></p><p>联合类型表示一个值可以是一种类型一直. 用 <strong>|</strong>分隔每个类型. 所以 number |string|boolean表示一个值可以是number,string,或bollean.<br>如果一个值是联合类型,我们只能访问此联合类型的所有类型里共有的成员.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Bird&#123;</span><br><span class="line">    fly();</span><br><span class="line">    layEggs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Fish()&#123;</span><br><span class="line">    swim();</span><br><span class="line">    layEggs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSmallPet</span>(<span class="params"></span>): <span class="title">Fish</span> | <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pet =getSmallPet();</span><br><span class="line">pet.layEggs(); <span class="comment">//okay</span></span><br><span class="line">pet.swim(); <span class="comment">//errors</span></span><br></pre></td></tr></table></figure></p><p>如果一个值得类型是A|B,我们能够确定的是它包含了A和B中的共有的成员. 这个例子里, Bird具有一个fly成员. 我们不能确定一个Bird | Fish类型的变量是否具有fly方法. 如果变量在运行时是Fish类型, 那么调用pet.fly()就出错了.</p><h2 id="类型保护与区分类型-Type-Guards-and-Differentiating-Types"><a href="#类型保护与区分类型-Type-Guards-and-Differentiating-Types" class="headerlink" title="类型保护与区分类型(Type Guards and Differentiating Types)"></a>类型保护与区分类型(Type Guards and Differentiating Types)</h2><p>联合类型适合于那些值可以为不同类型的情况. 但当我们想确切地了解是否为Fish时怎么办? JavaScript里常用来区分2个可能只的方法是检查成员是否存在.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pet=getSmallPet();</span><br><span class="line"></span><br><span class="line"><span class="comment">//每一个成员访问都会报错.</span></span><br><span class="line"><span class="keyword">if</span>(pet.swim)&#123;</span><br><span class="line">    pet.swim();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pet.fly)&#123;</span><br><span class="line">    pet.fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了让这段代码工作, 我们要使用类型断言:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pet= getSmallPet();</span><br><span class="line"><span class="keyword">if</span>(<span class="xml"><span class="tag">&lt;<span class="name">Fish</span>&gt;</span>pet).swim)&#123;</span></span><br><span class="line">    (&lt;Fish&gt;pet).swim();</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    (&lt;Bird&gt;pet).fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="用户自定义的类型保护"><a href="#用户自定义的类型保护" class="headerlink" title="用户自定义的类型保护"></a>用户自定义的类型保护</h3><p>这里可以注意到我们不得不多次使用类型断言. 假若我们一旦检查过类型, 就能在之后的每个分支里清楚地知道pet的类型的话就好了.</p><p>TypeScript 里的类型保护机制可以实现该功能. 类型保护就是一些表达式, 他们会在运行时检查以确保在某个作用域里的类型. 要定义一个类型保护, 我们只要简单的定义一个函数,它的返回值是一个类型谓词:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFish</span>(<span class="params">pet : Fish | Bird</span>): <span class="title">pet</span> <span class="title">is</span> <span class="title">Fish</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">Fish</span>&gt;</span>pet).swim!=undefined;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">``` </span></span><br><span class="line"><span class="xml">**pet is Fish**就是类型谓词. 谓词为 parameterName is Type这种形式. parameterName必须是来自于当前函数签名里的一个参数名.</span></span><br><span class="line"><span class="xml">每当使用一些变量调用isFish时,TypeScript会将变量缩减为那个具体的类型, 执拗这个类型与连梁的原始类型时兼容的.</span></span><br><span class="line"><span class="xml">```js</span></span><br><span class="line"><span class="xml">//'swim' 和 'fly'调用都没问题了</span></span><br><span class="line"><span class="xml">if(isFish(pet))&#123;</span></span><br><span class="line"><span class="xml">    pet.swim();</span></span><br><span class="line"><span class="xml">&#125;else&#123;</span></span><br><span class="line"><span class="xml">    pet.fly();</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure></p><p>注意TypeScript不仅知道在if分支里pet是Fish类型; 它还清楚在else分支里,一定不是Fish类型, 一定Bird类型.</p><h3 id="typeof类型保护"><a href="#typeof类型保护" class="headerlink" title="typeof类型保护"></a><em>typeof</em>类型保护</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNumber</span>(<span class="params">x:any</span>): <span class="title">x</span> <span class="title">is</span> <span class="title">number</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> x===<span class="string">"number"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isString</span>(<span class="params">x:any</span>):<span class="title">x</span> <span class="title">is</span> <span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> x====<span class="string">"string"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span>(<span class="params">value:string, padding: string|number</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isNumber(padding))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>(padding+<span class="number">1</span>).join(<span class="string">" "</span>)+value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isString(padding))&#123;</span><br><span class="line">        <span class="keyword">return</span> padding+value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Excepted string or number, got '<span class="subst">$&#123;padding&#125;</span>'.`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不必将<strong>typeof x===”number”</strong> 抽象成一个函数, 因为TypeScript可以将它识别为一个类型保护.</p><h3 id="instanceof-类型保护"><a href="#instanceof-类型保护" class="headerlink" title="instanceof 类型保护"></a><em>instanceof</em> 类型保护</h3><p>instanceof类型保护是通过构造函数来细化类型的一种方式. 比如:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">interface Padder&#123;</span><br><span class="line">    getPaddingString():string;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceRepeatingPadder</span> <span class="title">implements</span> <span class="title">Padder</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(private numSpaces:number)&#123;&#125;</span><br><span class="line">    getPaddingString()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>(<span class="keyword">this</span>.numSpaces+<span class="number">1</span>).join(<span class="string">' '</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringPadder</span> <span class="title">implements</span> <span class="title">Padder</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(private value:string)&#123;&#125;</span><br><span class="line">    getPaddingString()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomPadder</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.random()&lt;<span class="number">0.5</span>?</span><br><span class="line">    <span class="keyword">new</span> SpaceRepeatingPadder(<span class="number">4</span>)</span><br><span class="line">    :<span class="keyword">new</span> StringPadder(<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类型SpaceRepeatingPadder | StringPadder</span></span><br><span class="line"><span class="keyword">let</span> padder: Padder = getRandomPadder();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(padder <span class="keyword">instanceof</span> SpaceRepeatingPadder)&#123;</span><br><span class="line">    padder; <span class="comment">//类型细化为'spaceRepeatingPadder'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(padder <span class="keyword">instanceof</span> StringPadder)&#123;</span><br><span class="line">    padder; <span class="comment">//类型细化为 stringPadder</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>instanceof 的右侧要求是一个构造函数,TypeScript将细化为:</p><ol><li>此构造函数的prototype属性的类型,如果它的类型不为any的</li><li>构造签名所返回的类型的联合<br>以此顺序.</li></ol><h2 id="可以为null-的类型"><a href="#可以为null-的类型" class="headerlink" title="可以为null 的类型."></a>可以为null 的类型.</h2><p><a href="https://www.tslang.cn/docs/handbook/advanced-types.html" target="_blank" rel="noopener">https://www.tslang.cn/docs/handbook/advanced-types.html</a><br>TypeScript具有两种特殊的类型,null和undefined,它们分别具有null和undefined. 默认情况下, 类型检查器认为null与undefined可以赋值给任何类型. null与undefined是又有其他类型的一个有效值. 这意味着, 你阻止不了将它们赋值给其他类型.<br><strong>–strictNullChecks</strong>标记可以解决此错误: 当你声明一个变量时,它不会自动地包含null或undefined.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s=<span class="string">"foo"</span>;</span><br><span class="line">s=<span class="literal">null</span>; <span class="comment">//错误, 'null' 不能赋值给'string'</span></span><br><span class="line"><span class="keyword">let</span> sn: string | <span class="literal">null</span> =<span class="string">"bar"</span>;</span><br><span class="line">sn=<span class="literal">null</span>;<span class="comment">// 可以</span></span><br><span class="line"></span><br><span class="line">sn=<span class="literal">undefined</span>; <span class="comment">//error, 'undefined',不能赋值给'string' | 'null'</span></span><br></pre></td></tr></table></figure></p><p>按照javascript的语义, TypeScript会把null和undefined区别对待. string | null, string| undefined 和 string | undefined | null是不同的类型.</p><h3 id="可选参数和可选属性"><a href="#可选参数和可选属性" class="headerlink" title="可选参数和可选属性"></a>可选参数和可选属性</h3><p>使用了 –strictNullChecks, 可选参数会被自动加上 | undefined.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x:number,y?:number</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+(y||<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">f(<span class="number">1</span>);</span><br><span class="line">f(<span class="number">1</span>,<span class="literal">undefined</span>);</span><br><span class="line">f(<span class="number">1</span>,<span class="literal">null</span>);<span class="comment">// error, 'null' is not assignable to 'number | undefined'</span></span><br></pre></td></tr></table></figure></p><p>可选属性也会有同样的处理:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Class C&#123;</span><br><span class="line">    a:number;</span><br><span class="line">    b?:number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c=<span class="keyword">new</span> C();</span><br><span class="line">c.a=<span class="number">12</span>;</span><br><span class="line">c.a=<span class="literal">undefined</span>; <span class="comment">//error, 'undefined' is not assignable to 'number'</span></span><br><span class="line">c.b=<span class="number">13</span>;</span><br><span class="line">c.b=<span class="literal">undefined</span>; <span class="comment">//ok</span></span><br><span class="line">c.b=<span class="literal">null</span>; <span class="comment">//error, 'null' is not assignable to 'number | undefined'</span></span><br></pre></td></tr></table></figure></p><h3 id="类型保护和类型断言"><a href="#类型保护和类型断言" class="headerlink" title="类型保护和类型断言"></a>类型保护和类型断言</h3><p>由于可以为null的保护类型是通过联合类型实现,name你需要使用类型保护来去除null. 幸运地是这与JavaScript里写的代码一致:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">sn:string | null</span>) :<span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sn ==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"default"</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里明显地去除了null,也可以使用短路运算符:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">sn:string | null</span>):<span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sn || <span class="string">"default"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果编译器不能去除null或undefined, 可以使用类型断言手动去除. 语法是添加!后缀: identifier!从identifier的类型里去除了null和undefined:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">broken</span>(<span class="params">name :string | null</span>):<span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">postfix</span>(<span class="params">epithet:string</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name.charAt(<span class="number">0</span>)+<span class="string">'. the '</span> + epihet; <span class="comment">//error, 'name' is possibly null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    name =name || <span class="string">"Bob"</span>;</span><br><span class="line">    <span class="keyword">return</span> postfix(<span class="string">'great'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fixed</span>(<span class="params">name:string | null</span>):<span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">postfix</span>(<span class="params">epithet:string</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name!.charAt(<span class="number">0</span>)+<span class="string">'. the'</span>+epithet; <span class="comment">//ok</span></span><br><span class="line">    &#125;</span><br><span class="line">    name =name || <span class="string">"Bob"</span>;</span><br><span class="line">    <span class="keyword">return</span> postfix(<span class="string">'great'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>本例使用了嵌套函数,因为编译器无法去除嵌套函数的null(除非是立即调用的函数表达式). 因为它无法跟踪所有对嵌套函数的调用, 尤其是你讲内存函数作为外层函数的返回值. 如果无法知道函数在哪里被调用,就无法知道调用时name的类型.</p><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>类型别名会给一个类型起个新名字. 类型别名有时和接口很想,但是可以作用于原始值, 联合类型, 元组即其他任何你需要手写的类型.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type Name=string,</span><br><span class="line">type NameResolver=<span class="function"><span class="params">()</span>=&gt;</span>string;</span><br><span class="line">type NameOrResolver =Name | NameResolver;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">n: NameOrResolver</span>):<span class="title">Name</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> n ===<span class="string">"string"</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>起别名不会新建一个类型- 它创建了一个新名字来引用那个类型. 给原始类型起别名通常没什么用, 尽管可以作为文档的一种形式使用.</p><p>同接口一样,类型别名也可以使是泛型 - 我们可以添加类型参数并且在别名声明的右侧传入:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Container&lt;T&gt; = &#123;<span class="attr">value</span>:T&#125;;</span><br></pre></td></tr></table></figure></p><p>我们可以使用类型别名来在属性里引用自己:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Tree&lt;T&gt; = &#123;</span><br><span class="line">    value: T;</span><br><span class="line">    left: Tree&lt;T&gt;;</span><br><span class="line">    right: Tree&lt;T&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>与交叉类型一起使用, 我们可以创建出一些很奇怪的类型.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type LinkedList&lt;T&gt; = T &amp; &#123;<span class="attr">next</span> :LinkedList&lt;T&gt;&#125;;</span><br><span class="line"></span><br><span class="line">interface Person&#123;</span><br><span class="line">    name :string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> people : LinkedList&lt;Person&gt;;</span><br><span class="line"><span class="keyword">var</span> s= people.name;</span><br><span class="line"><span class="keyword">var</span> s= people.next.name;</span><br><span class="line"><span class="keyword">var</span> s=people.next.next.name;</span><br><span class="line"><span class="keyword">var</span> s= people.next.net.next.name;</span><br></pre></td></tr></table></figure></p><p>然而, 类型别名不能胡子安在声明右侧的任何地方.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Yikes = <span class="built_in">Array</span>&lt;Yikes&gt;; <span class="comment">//error</span></span><br></pre></td></tr></table></figure></p><h3 id="接口-vs-类型别名"><a href="#接口-vs-类型别名" class="headerlink" title="接口 vs. 类型别名"></a>接口 vs. 类型别名</h3><p>类型别名可以像接口一样; 然而, 仍有一些细微差别.</p><ul><li><p>接口创建了一个新的名字,可以在其它任何地方使用. 类型别名并不创建新名字-比如,错误信息就不会使用别名. 在下面的示例代码里, 在编译器中将鼠标悬停在interfaced上, 显示它返回的是Interface, 但悬停在在aliased上时,显示的却是对象字面量类型.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Alias= &#123;<span class="attr">num</span>: number&#125;;</span><br><span class="line">interface Interface&#123;</span><br><span class="line">    num: number;</span><br><span class="line">&#125;</span><br><span class="line">declare <span class="function"><span class="keyword">function</span> <span class="title">aliased</span>(<span class="params">arg: Alias</span>):<span class="title">Alias</span>;</span></span><br><span class="line"><span class="function"><span class="title">declare</span> <span class="title">function</span> <span class="title">interfaced</span>(<span class="params">arg: Interface</span>): <span class="title">Interface</span>;</span></span><br></pre></td></tr></table></figure></li><li><p>另一个重要区别是类型别名不能被<strong>extends</strong>和<strong>implements</strong>(自己也不能extends喝implements其他类型). 因为<strong>软件中的对象应该对于扩展是开放的,但是对于修改是封闭的</strong>, 应该尽量去使用接口代替类型别名.</p></li><li>另一方面,如果无法通过接口来描述一个类型并且需要使用联合类型或元组类型,这时通常会使用类型别名.</li></ul><h2 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h2><p>字符串字面量累心允许你指定字符胡灿必须的固定值. 在实际应用中,字符串字面量类型可以与联合类型,类型保护和类型别名很好的配合. 通过结合使用这些特性, 可以实现类似枚举的字符串.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">type Easing =<span class="string">'ease-in'</span> | <span class="string">'ease-out'</span> | <span class="string">'ease-in-out'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UIElement</span> </span>&#123;</span><br><span class="line">    animate(dx: number, <span class="attr">dy</span>:number,<span class="attr">easing</span>:Easing)&#123;</span><br><span class="line">        <span class="keyword">if</span>(easeing === <span class="string">"ease-in"</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(easing ===<span class="string">"ease-out"</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(easeing ===<span class="string">"ease-in-out"</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//error! should not pass null or undefined.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> button =<span class="keyword">new</span> UIElement();</span><br><span class="line">button.animate(<span class="number">0</span>,<span class="number">0</span>,<span class="string">'ease-in'</span>);</span><br><span class="line">button.animate(<span class="number">0</span>,<span class="number">0</span>,<span class="string">'uneasy'</span>); <span class="comment">//error: 'uneasy' is not allowed here.</span></span><br></pre></td></tr></table></figure></p><p>你只能从三中允许的字符串中选择其一来作为参数传递, 传入其他值则会产生错误<br><code>Agrument of type &quot;uneasy&quot; is not assignable to parameter of type &#39;&quot;ease-in&quot; | &quot;ease-out&quot; | &quot;ease-in-out&quot;&#39;</code><br>字符串字面量类型还可以用于区分函数重载:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">tag:<span class="string">"img"</span></span>):<span class="title">HTMLImageElement</span>;</span></span><br><span class="line"><span class="function"><span class="title">function</span> <span class="title">createElement</span>(<span class="params">tagName:<span class="string">"input"</span></span>); <span class="title">HTMLInputElement</span>;</span></span><br><span class="line"><span class="function">//<span class="title">more</span> <span class="title">overloads</span></span></span><br><span class="line"><span class="function"><span class="title">function</span> <span class="title">createElement</span>(<span class="params">tagName:string</span>):<span class="title">Element</span></span>&#123;</span><br><span class="line">    <span class="comment">//code goes heere...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="可辨识联合-Discriminated-Unions"><a href="#可辨识联合-Discriminated-Unions" class="headerlink" title="可辨识联合(Discriminated Unions)"></a>可辨识联合(Discriminated Unions)</h2><p>你可以合并字符串字面量类型,联合类型,类型保护和类型别名来创建一个叫做 <em>可辨识联合</em>的高级模式,它也称作<em>标签联合</em>或<em>代数数据类型</em>.<br>可辨识联合在函数式的碧娜城很有用处. 一些语言会自动地为你辨识联合; 而TypeScript则基于已有的JavaScript模式, 它具有3个要素:</p><ol><li>具有普通的字符串字面量属性- 可辨识的特征</li><li>一个类型别名包含了那些类型的联合- 联合</li><li>此属性的类型保护.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface Square&#123;</span><br><span class="line">    kind:<span class="string">"square"</span>;</span><br><span class="line">    size:number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Rectangle&#123;</span><br><span class="line">    kind:<span class="string">"rectangle"</span>;</span><br><span class="line">    width:number;</span><br><span class="line">    height:number;</span><br><span class="line">&#125;</span><br><span class="line">interface Circle&#123;</span><br><span class="line">    kind :<span class="string">"circle"</span>;</span><br><span class="line">    radius:number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>首先我们声明了将要联合的接口. 每个接口都有kind属性但有不同的字符串字面量类型. kind属性称做<em>可辨识的特征或标签</em>. 其它的属性则特定于各个接口. 注意,目前各个接口间是没有联系的. 下面我们把他们联合到一起:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type Shape =Square | Rectangle | Circle;</span><br><span class="line"></span><br><span class="line"><span class="comment">//现在我们使用可辨识联合:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">s:Shape</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(s.kind)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"square"</span>: <span class="keyword">return</span> s.size * s.size;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"rectangle"</span>: <span class="keyword">return</span> s.height * s.width;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"circle"</span>: <span class="keyword">return</span> <span class="built_in">Math</span>.PI * s.radius **<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="完整性检查"><a href="#完整性检查" class="headerlink" title="完整性检查"></a>完整性检查</h3><p>当没有涵盖所有可辨识联合的变化时,我们想让编译器可以通知我们. 如: 如果我们添加了Triangle到Shape, 我么同事还需要更新 area:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type Shape =Square | Rectangle | Circle | Triangle;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">s:Shape</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(s.kind)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"square"</span>: <span class="keyword">return</span> s.size* s.size;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"rectangle"</span>: <span class="keyword">return</span> s.height * s.width;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"circle"</span>: <span class="keyword">return</span> <span class="built_in">Math</span>.PI * s.radius**<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//should error here - we didn't handle case "triangle"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有两个找那个方式可以实现. 首先是启用 –stricNullChecks 并且制定一个返回值类型:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fuction area(s: Sharp) :number &#123; <span class="comment">//error: returns number | undefined</span></span><br><span class="line">    <span class="keyword">switch</span>(s.kind)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"square"</span>: <span class="keyword">return</span> s.size * s.size;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"rectangle"</span>: <span class="keyword">return</span> s.height *s.width;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"circle"</span>: <span class="keyword">return</span> <span class="built_in">Math</span>.PI * s.radius **<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为switch没有包含所有情况, 所以TypeScript认为这个函数有时候会返回undefined. 如果你明确指出了但会值类型为number,那么会看到一个错误, 因为实际上返回值的类型为 number | undefined. 然而, 这种方法的存在些微妙之处且<strong>–strictNullChecks</strong>对旧代码支持不好.<br>第二种方法使用<strong>never</strong>类型,编译器用他来进行完整性检查:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assertNever</span>(<span class="params">x:never</span>):<span class="title">never</span></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Unexpected object:'</span>+x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">s:Shape</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(s.kind)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"square"</span>: <span class="keyword">return</span> s.size*s.size;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"rectangle"</span>: <span class="keyword">return</span> s.height * s.width;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"circle"</span>: <span class="keyword">return</span> <span class="built_in">Math</span>.PI * s.radius **<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">return</span> assertNever(s); <span class="comment">//error here if there are missing cases</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里, assertNerver检查s是否为never类型 - 即为出去所有可能情况后剩下的类型. 如果你忘记了某个case, 那么s将具有一个真实的类型并且你会得到一个错误, 这种方式需要你定义一个额外的函数, 但是你忘记某个case的受也更加明显.</p><h2 id="多态的this类型"><a href="#多态的this类型" class="headerlink" title="多态的this类型"></a>多态的<em>this</em>类型</h2><p>多态的this类型表示的是某个包含类或接口的子类型. 这被称作 F- bounded多态性. 它能很容易的标签连贯接口键的继承, 比如, 在计算器的例子里, 在每个操作之后都返回this 类型.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicCalculator</span></span>&#123;</span><br><span class="line">    public <span class="keyword">constructor</span>(potected value:number=0)&#123;&#125;</span><br><span class="line">    public currentValue():number&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">    public add(operand:number):<span class="keyword">this</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value +=operand;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    public multiply(operand:number):<span class="keyword">this</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value *= operand;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//... other operations go here...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v =<span class="keyword">new</span> BasicCalculator(<span class="number">2</span>)</span><br><span class="line">        .multiply(<span class="number">5</span>)</span><br><span class="line">        .add(<span class="number">1</span>)</span><br><span class="line">        .currentValue();</span><br></pre></td></tr></table></figure></p><p>由于这个类使用了this类型. 你可以继承它, 新的类可以直接使用之前的方法,不需要做任何的改变.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScientificCalculator</span> <span class="keyword">extends</span> <span class="title">BaiscCalculator</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">constructor</span>(value=0)&#123;</span><br><span class="line">        <span class="keyword">super</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    public sin()&#123;</span><br><span class="line">        <span class="keyword">this</span>.value=<span class="built_in">Math</span>.sin(<span class="keyword">this</span>.value);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.. other operations go here...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v=<span class="keyword">new</span> ScientificCalculator(<span class="number">2</span>)</span><br><span class="line">        .multiply(<span class="number">5</span>)</span><br><span class="line">        .sin()</span><br><span class="line">        .add(<span class="number">1</span>)</span><br><span class="line">        .currentValue();</span><br></pre></td></tr></table></figure></p><p>如果没有this类型, ScientificCalculator 就不能够在继承BasicCalculator的同事还保持接口的连贯性. multiply 就会返回BasicCalculator, 它并没有sin方法. 然而,使用this类型,multiplyhi返回this, 在这里就是ScientificCalculator.</p><h2 id="索引类型-Index-types"><a href="#索引类型-Index-types" class="headerlink" title="索引类型(Index types)"></a>索引类型(Index types)</h2><p>使用索引类型,编译器就能够检查使用了动态属性名的代码. 例如, 一个常见的Javascript模式是从对象中选取属性的子集.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pluck</span>(<span class="params">o, names</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> names.map(<span class="function"><span class="params">n</span>=&gt;</span>o[n])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在TypeScript里使用此函数,通过<strong>索引类型查询</strong>和<strong>索引访问</strong>操作符:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function pluck&lt;T,K extends keyof T&gt;(o:, names:K[]):T[K][]&#123;</span><br><span class="line">    <span class="keyword">return</span> names.map(<span class="function"><span class="params">n</span>=&gt;</span>o[n]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Person&#123;</span><br><span class="line">    name:string,</span><br><span class="line">    age:number</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person : Person&#123;</span><br><span class="line">    name: <span class="string">"Jarid"</span>,</span><br><span class="line">    age:<span class="number">35</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strings: string[] = pluck(person,[<span class="string">'name'</span>]); <span class="comment">//ok, string[]</span></span><br></pre></td></tr></table></figure></p><p>编译器会检查<em>name</em>是否真的是<em>Person</em>的一个属性. 本例还引入了几个新的类型操作符, 首先 keyof T, <strong>索引类型查询操作符</strong>. 对于任何类型T, keyof T的结构为T上已知的公共属性名的联合. 如:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> personProps : keyof Person; <span class="comment">// 'name' | 'age'</span></span><br></pre></td></tr></table></figure></p><p><strong>keyof Person</strong>是完全可以与<strong>‘name’|’age’</strong>互相替换的. 不同的是如果你添加了其他的属性到Person, 例如address: string,那么<strong>keyof Person</strong>会自动变为 ‘name’ | ‘age’ | ‘address’.  你可以像pluck函数这类上下文里使用keyof, 因为使用之前你并不清楚可能出现的属性名. 但编译器会检查你是否传入了正确的属性名给pluck.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pluck(person,[<span class="string">'age'</span>,<span class="string">'unknow'</span>]); <span class="comment">// error, 'unknow' is not in 'name' | 'age'</span></span><br></pre></td></tr></table></figure></p><p>第二个操作符是T[K],<strong>索引访问操作符</strong>. 这里, 类型语法反映了表达式语法. 这意味着person[‘name’]具有类型Perosn[‘name’] - 在我们的例子里则为string类型. 然而,就像索引类型查新一样, 你可以在普通的上下文里使用T[K], 这正是它的强大所在. 你只要确保类型变量<strong>K extends keyof T</strong>就可以了. 如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function getProperty&lt;T, K extends keyof T&gt;(o:T,name:K):T[K]&#123;</span><br><span class="line">    <span class="keyword">return</span> o[name]; <span class="comment">// o[name] is of type T[K]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>getProperty里的o:T 和name:K, 意味着o[name]:T[K]. 当你返回T[K]的结果, 编译器会实例化键的真实类型. 因此getProperty的返回值类型会随着你需要的属性改变.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name: stirng = getProperty(person,<span class="string">'name'</span>);</span><br><span class="line"><span class="keyword">let</span> age:number=getProperty(person,<span class="string">'age'</span>)</span><br><span class="line"><span class="keyword">let</span> unkndow= getProperty(person,<span class="string">'unknow'</span>); <span class="comment">//error, 'unknow' is not in 'name' | 'age'</span></span><br></pre></td></tr></table></figure></p><h3 id="索引类型和字符串索引签名"><a href="#索引类型和字符串索引签名" class="headerlink" title="索引类型和字符串索引签名"></a>索引类型和字符串索引签名</h3><p>keyof 和T[K]与字符串索引签名进行交互. 如果你有一个嗲you字符串索引签名的类型,那么keyof T会是string. 并且T[string]为索引签名的类型.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="built_in">Map</span>&lt;T&gt;&#123;</span><br><span class="line">    [key: stirng]:T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> keys: keyof <span class="built_in">Map</span>&lt;number&gt;; <span class="comment">//string</span></span><br><span class="line"><span class="keyword">let</span> value: <span class="built_in">Map</span>&lt;number&gt;[<span class="string">'foo'</span>];<span class="comment">// number</span></span><br></pre></td></tr></table></figure></p><h2 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface PersonPartial&#123;</span><br><span class="line">    name?: string;</span><br><span class="line">    age? : number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者我们想要一个只读版本:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface PersonReadonly&#123;</span><br><span class="line">    readonly name:string;</span><br><span class="line">    readonly age:number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>TypeScript提供了从旧类型中创建新类型的一种方式 - <strong>映射类型</strong>. 在映射类型里, 新类型以相同的形式去转换旧类型里每个属性. 例如, 你可以令每个属性为readonly类型或可选的.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Readonly&lt;T&gt; =&#123;</span><br><span class="line">    readonly [P <span class="keyword">in</span> keyof T]: T[P]</span><br><span class="line">&#125;</span><br><span class="line">type Partial&lt;T&gt;=&#123;</span><br><span class="line">    [P <span class="keyword">in</span> keyof T]? :T[P];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>像下面这样使用:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type PerosnPartial =Partial&lt;Person&gt;;</span><br><span class="line">type ReadonlyPerson =Readonly&lt;Person&gt;;</span><br></pre></td></tr></table></figure></p><p>下面来看最简单的映射类型和它的组成部分:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type keys= <span class="string">'option1'</span> | <span class="string">'option2'</span>;</span><br><span class="line">type Flags= &#123; [K <span class="keyword">in</span> Keys]: boolean&#125;</span><br></pre></td></tr></table></figure></p><p>它的语法与索引签名的语法类型,内部使用了 for…in. 具有三个部分:</p><ol><li>类型变量K, 它会依次绑定到每个属性</li><li>字符串字面量联合的Keys, 它包含了要迭代的属性名的集合</li><li>属性的结果类型</li></ol><p>Keys是硬编码的属性名列表并且属性类型永远是boolean, 因此这个映射的类型等同于:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Flags=&#123;</span><br><span class="line">    option1:boolean;</span><br><span class="line">    option2: boolean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在真正的应用里, 可能不同于上面的Readonly或Partial, 它们会给予一些已存在的类型,且按照一定的方式转换字段. 这就是keyof 和索引访问类型要做的事情:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type NullablePerson =&#123; [P <span class="keyword">in</span> keyof Person]: Person[P] | <span class="literal">null</span>&#125;</span><br><span class="line">type PartialPerson = &#123;[P <span class="keyword">in</span> keyof Person]?:Person[P]&#125;</span><br></pre></td></tr></table></figure></p><p>但他更有用的地方是可以有一些通用版本<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type Nullable&lt;T&gt; = &#123; [P <span class="keyword">in</span> keyof T]:T[P] | <span class="literal">null</span>&#125;</span><br><span class="line">type Partial&lt;T&gt; = &#123;[P <span class="keyword">in</span> keyof T]?:T[P]&#125;</span><br></pre></td></tr></table></figure></p><p>在这些例子里, 属性列表是keyof T且结果类型是T[P]的变体. 这是使用通用映射类型的一个好模板. 因为这类转换时<strong>同态</strong>的, 映射只作用域T的属性而没有其他的. 编译器知道在添加任何新属性之前可以拷贝所有存在的小户型修饰符. 例如, 假设Perosn.name是只读的, 那么Partial<perosn>.name也将是只读且为可选的.</perosn></p><p>另一个例子, T[P]被包裹在Proxy<t>类里:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type <span class="built_in">Proxy</span>&lt;T&gt; =&#123;</span><br><span class="line">    get():T;</span><br><span class="line">    set(value:T):<span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Proxify&lt;T&gt;=&#123;</span><br><span class="line">    [P <span class="keyword">in</span> keyof T]: <span class="built_in">Proxy</span>&lt;T[P]&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxify</span>&lt;<span class="title">T</span>&gt;(<span class="params">o:T</span>): <span class="title">Proxify</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//...wrap proxies...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> proxyProps= propify(props);</span><br></pre></td></tr></table></figure></t></p><p>注意Readonly<t>和Partial<t>用处不小, 因此他们与Pick 和Record一同被包含进了TypeScript的标准里:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Pick&lt;T, K extends keyof T&gt;=&#123;</span><br><span class="line">    [P <span class="keyword">in</span> K] :T[P];</span><br><span class="line">&#125;</span><br><span class="line">type Record&lt;K extends string, T&gt;=&#123;</span><br><span class="line">    [P <span class="keyword">in</span> K]:T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></t></p><p>Readonly, Partial和Pick是同态的. 但 Record不是. 因为并不需要输入类型来拷贝属性,所以它不属于同态:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type ThreeStringProps =Record&lt;<span class="string">'prop1'</span> | <span class="string">'prop2'</span> | <span class="string">'prop3'</span>,string&gt;</span><br></pre></td></tr></table></figure></p><p>非同态类型本质上会创建新的属性. 因此他们不会从它处拷贝属性值.</p><h3 id="由映射类型进行推断"><a href="#由映射类型进行推断" class="headerlink" title="由映射类型进行推断"></a>由映射类型进行推断</h3><p>了解了如何包装一个类型的属性,name接下来就是如何拆包.:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unproify</span>&lt;<span class="title">T</span>&gt;(<span class="params">t:Proify&lt;T&gt;</span>):<span class="title">T</span></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result= &#123;&#125; <span class="keyword">as</span> T;</span><br><span class="line">    <span class="keyword">for</span>(cnst k <span class="keyword">in</span> t)&#123;</span><br><span class="line">        result[k]=t[k].get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> originalProps =unproify(proxyProps);</span><br></pre></td></tr></table></figure></p><p>注意 这个拆包推断只适用于同态的映射类型. 如果映射类型不是同态的,那么需要给拆包函数一个明确的类型参数.</p><p>THE END!</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;交叉类型-intersection-types&quot;&gt;&lt;a href=&quot;#交叉类型-intersection-types&quot; class=&quot;headerlink&quot; title=&quot;交叉类型(intersection types)&quot;&gt;&lt;/a&gt;交叉类型(intersection types)&lt;/h2&gt;&lt;p&gt;交叉类型是将多个类型合并为一个类型. 这让我们可以把现有的多种类型叠加到一起为一种类型, 它包含了所需的所有类型的特性. 例如, Person &amp;amp; Serializable &amp;amp; Loggable 同时是Person 和 Serializable和Loggable. 就是说这个类型的对象同时拥有了这三种类型的成员.&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;extend&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;T&lt;/span&gt;,&lt;span class=&quot;title&quot;&gt;U&lt;/span&gt;&amp;gt;(&lt;span class=&quot;params&quot;&gt;first:T,second:U&lt;/span&gt;):&lt;span class=&quot;title&quot;&gt;T&lt;/span&gt;&amp;amp;&lt;span class=&quot;title&quot;&gt;U&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; result=&lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;T&lt;/span&gt; &amp;amp; &lt;span class=&quot;attr&quot;&gt;U&lt;/span&gt;&amp;gt;&lt;/span&gt;&amp;#123;&amp;#125;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;xml&quot;&gt;    for(let id in first)&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        (&amp;lt;any&amp;gt;result)[id]=(&amp;lt;any&amp;gt;first)[id];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for(let id in second)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(!result.hasOwnProperty(id))&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            (&amp;lt;any&amp;gt;result)[id]=(&amp;lt;any&amp;gt;second)[id];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return reuslt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class Person&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    constructor(public name:string)&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;interface Loggable&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    log():void;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class ConsoleLogger implements Loggable&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    log()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var jim=extend(new Person(&#39;Jim&#39;),new ConsoleLogger());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var n=jim.name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;jim.log();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="编程" scheme="https://xiaoxiaocoder.github.io/categories/programming/"/>
    
      <category term="javascript" scheme="https://xiaoxiaocoder.github.io/categories/programming/javascript/"/>
    
      <category term="typescript" scheme="https://xiaoxiaocoder.github.io/categories/programming/javascript/typescript/"/>
    
    
      <category term="typescript" scheme="https://xiaoxiaocoder.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>[TypeScript 07]手册指南: 类型兼容性</title>
    <link href="https://xiaoxiaocoder.github.io/programming/javascript/typescript/2017-08-05-typescript-07-type-compatibility.html"/>
    <id>https://xiaoxiaocoder.github.io/programming/javascript/typescript/2017-08-05-typescript-07-type-compatibility.html</id>
    <published>2017-08-05T11:58:12.000Z</published>
    <updated>2017-12-09T06:32:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Type-Compatibility"><a href="#Type-Compatibility" class="headerlink" title="Type Compatibility"></a>Type Compatibility</h2><p><a href="http://www.typescriptlang.org/docs/handbook/type-compatibility.html" target="_blank" rel="noopener">handbook</a></p><p><strong>Introduction</strong><br>Type compatibility in TypeScript is based on structural subtyping. Structural typing is a way of relating types based solely on their members. This is in contrast with norminal typing. Consider the following code:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Named&#123;</span><br><span class="line">    name:string;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    name:string</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p:Named;</span><br><span class="line">p=<span class="keyword">new</span> Person();<span class="comment">//ok, because of structural typing.</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p><strong>关于可靠性的注意事项</strong><br>TypeScript的类型系统允许某些在编译阶段无法确认其安全性的操作. 当一个类型系统具有此属性时,被当做是”不可靠”的. TypeScript允许这种不可靠行为的发生时经过思考的.</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>TypeScript结构化类型系统的基本规则是, 如果x要兼容y,那么y至少具有与x相同的属性.如:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Named&#123;</span><br><span class="line">    name:string;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> x:Named;</span><br><span class="line"><span class="comment">//y's inferred type is &#123;name:string,location:string&#125;</span></span><br><span class="line"><span class="keyword">let</span> y=&#123;<span class="attr">name</span>:<span class="string">"Alice"</span>, <span class="attr">location</span>:<span class="string">"Seattle"</span>&#125;</span><br><span class="line">x=y;</span><br></pre></td></tr></table></figure></p><p>这里要检查y是否能赋值给x,编译器检查x找那个的每个属性,看是否能在y中也找到对应属性.  y包含name的string类型成员,满足条件.<br>检查函数参数时,使用相同的规则:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">n:Named</span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'Hello,'</span>+n.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet(y); <span class="comment">//Ok</span></span><br></pre></td></tr></table></figure></p><p>注意,y有额外属性location,但这不会引发错误. 只有目标类型的成员会被一一检查是否兼容.</p><h2 id="比较两个函数"><a href="#比较两个函数" class="headerlink" title="比较两个函数"></a>比较两个函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x=<span class="function">(<span class="params">a:number</span>)=&gt;</span><span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> y=<span class="function">(<span class="params">b:number,s:string</span>)=&gt;</span><span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">y=x; <span class="comment">//ok  x的每个参数在y中都能找到对应的参数,所以允许赋值</span></span><br><span class="line">x=y; <span class="comment">//error y中有必须的第二个参数,但x没有,所以不允许赋值</span></span><br></pre></td></tr></table></figure><p>关于为什么允许<strong>忽略</strong>参数.原因是忽略额外的参数在Javascript中是很常见的.<br>如: Array#forEach给回调函数传3个参数:数组元素,索引和整个数组. 尽管如下,传入一个只是用第一个参数的回调函数也是很有用的.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> items=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//Don't force these extra arguments</span></span><br><span class="line">items.forEach(<span class="function">(<span class="params">item,index,array</span>)=&gt;</span><span class="built_in">console</span>.log(item));</span><br><span class="line"></span><br><span class="line"><span class="comment">//should be ok!</span></span><br><span class="line">items.forEach(<span class="function">(<span class="params">item</span>)=&gt;</span><span class="built_in">console</span>.log(item));</span><br></pre></td></tr></table></figure></p><p>返回值类型<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x=()=(&#123;<span class="attr">name</span>:<span class="string">"Alice"</span>&#125;);</span><br><span class="line"><span class="keyword">let</span> y-()=(&#123;<span class="attr">name</span>:<span class="string">"Alice"</span>,<span class="attr">location</span>:<span class="string">"Seattle"</span>&#125;);</span><br><span class="line"></span><br><span class="line">x=y; <span class="comment">//Ok</span></span><br><span class="line">y=x; <span class="comment">//error because x() lacks a location property</span></span><br></pre></td></tr></table></figure></p><p>类型系统强制源函数的返回值必须是目标函数返回值类型的子类型.</p><h2 id="函数参数双向协变"><a href="#函数参数双向协变" class="headerlink" title="函数参数双向协变"></a>函数参数双向协变</h2><p><a href="https://www.tslang.cn/docs/handbook/type-compatibility.html" target="_blank" rel="noopener">https://www.tslang.cn/docs/handbook/type-compatibility.html</a><br>当比较函数参数类型时, 只有当源函数参数能够赋值给目标函数或者反过来时才能赋值成功. 这是不稳定的,因为调用者可能传入了一个具有更精确类型信息的函数. 但是调用这个传入的函数的时候却使用了不是那么警觉的类型信息. 实际上,这极少会发生错误,并且能更改实现很多Javascript里常见的模式. 如:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">enum EventType&#123;Mouse, Keyboard&#125;</span><br><span class="line">interface Event &#123;<span class="attr">timestamp</span>:number&#125;</span><br><span class="line">interface MouseEvent extends Event &#123; <span class="attr">x</span>:number, <span class="attr">y</span>:number&#125;</span><br><span class="line">interface KeyEvent extends Event &#123; <span class="attr">keyCode</span>:number&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listenEvent</span>(<span class="params">eventType: EventType, handler: (n:Event</span>)=&gt;<span class="title">void</span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Unsouund, but useful and common</span></span><br><span class="line">listenEvent(EventType.Mouse, (e:MouseEvent)=&gt;<span class="built_in">console</span>.log(e.x + <span class="string">','</span>+e.y));</span><br><span class="line"></span><br><span class="line"><span class="comment">//undesirable alternatives in presence of soundness</span></span><br><span class="line">listenEvent(EventType.Mouse, (e:Event)=&gt;<span class="built_in">console</span>.log((&lt;MouseEvnet&gt;e).x+ ","+(&lt;MouseEvent&gt;e).y));</span><br><span class="line"></span><br><span class="line">//still disallowwd(clear error). Type safety enforced for wholly incompatible types</span><br><span class="line">listenEvent(EventType.Mouse,(e:number)=&gt;console.log(e));</span><br></pre></td></tr></table></figure></p><h2 id="可选参数及剩余参数"><a href="#可选参数及剩余参数" class="headerlink" title="可选参数及剩余参数"></a>可选参数及剩余参数</h2><p>比较函数兼容性的时候,可选参数与必须参数是可互换的. 源类型上有额外的可选参数不是错误, 目标类型的可选参数在源类型里没有对应的参数也不是错误.</p><p>当一个函数有剩余参数时,它被当做无限个可选参数书.</p><p>这对于类型系统来说是不稳定的,但从运行时的角度来看, 可选参数一般来说是不强制的. 因为对于大多数函数来说相当于船赌了一些undefined.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invokeLater</span>(<span class="params">args:any[],callback:(...args:any[]</span>)=&gt;<span class="title">void</span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//unsound - invokeLater "might" provide any number of arguments</span></span><br><span class="line">invokeLater([<span class="number">1</span>,<span class="number">2</span>],(x,y)=&gt;<span class="built_in">console</span>.log(x+<span class="string">','</span>+y));</span><br><span class="line"></span><br><span class="line"><span class="comment">//confusing (a and y are actually required) and undiscoverable</span></span><br><span class="line">invokeLater([<span class="number">1</span>,<span class="number">2</span>],(x?,y?)=&gt;<span class="built_in">console</span>.log(x+<span class="string">','</span>+y))</span><br></pre></td></tr></table></figure></p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举类型与数字类型兼容, 并且数字类型与枚举类型兼容. 不同的么牛类型之间是不兼容的.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum Status &#123;Ready, Waitting&#125;;</span><br><span class="line">enum Color &#123;Red, Blue, Green&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> status=Status.Ready;</span><br><span class="line">status=Color.Green; <span class="comment">//error</span></span><br></pre></td></tr></table></figure></p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类与对象字面量和接口差不多,但是有一点: 类有静态部分和实例部分的类型. 比较两个类类型的对象时, 只有实例的成员会被比较. 静态成员和构造函数不在比较的范围内.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    feet: number;</span><br><span class="line">    <span class="keyword">constructor</span>(name:string,numFeet:number)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Size</span></span>&#123;</span><br><span class="line">    feet:number;</span><br><span class="line">    <span class="keyword">constructor</span>(numFeet:number)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a :Animal;</span><br><span class="line"><span class="keyword">let</span> b: Size;</span><br><span class="line"></span><br><span class="line">a=s; <span class="comment">//ok</span></span><br><span class="line">s=a;<span class="comment">// ok</span></span><br></pre></td></tr></table></figure></p><h3 id="类的私有成员"><a href="#类的私有成员" class="headerlink" title="类的私有成员"></a>类的私有成员</h3><p>私有成员会影响兼容性判断. 当类的实例用来检查兼容时, 如果目标类型包含一个私有成员, 那么源类型必须包含来自同一个类的这个私有成员. 这允许自雷赋值给弗雷, 但是不能赋值给其他有同样类型的类.</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>因为TypeScript 是解构性的类型系统, 类型擦书只影响使用其作为类型一部分的结果类型.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Empty&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> x:Empty&lt;number&gt;;</span><br><span class="line"><span class="keyword">let</span> y:Empty&lt;string&gt;;</span><br><span class="line"></span><br><span class="line">x=y;<span class="comment">// okay, y matches structure of x</span></span><br></pre></td></tr></table></figure></p><p>上面的代码里, x和y是兼容的. 因为他们的结构使用类型参数并没有什么不同, 增加一个成员, 就能看书如何工作:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface NotEmpty&lt;T&gt;&#123;</span><br><span class="line">    data: T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x: NotEmpty&lt;number&gt;;</span><br><span class="line"><span class="keyword">let</span> y: NOtEmpty&lt;string&gt;;</span><br><span class="line"></span><br><span class="line">x=y; <span class="comment">//error,x and y are not compatible</span></span><br></pre></td></tr></table></figure></p><p>在这里, 泛型类型在使用时就好比不是一个泛型类型.</p><p>对于没有指定泛型类型的泛型参数时, 会吧所有泛型参数当成any比较. 然后用结果类型进行比较.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> identity =<span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt;(<span class="params">x:T</span>):<span class="title">T</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> reverse=<span class="function"><span class="keyword">function</span>&lt;<span class="title">U</span>&gt;(<span class="params">y:U</span>):<span class="title">U</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">identity =reverse; <span class="comment">//okay because (x:any)=&gt; any matches (y: any)=&gt;any</span></span><br></pre></td></tr></table></figure></p><h2 id="高级主题"><a href="#高级主题" class="headerlink" title="高级主题"></a>高级主题</h2><h3 id="子类型与赋值"><a href="#子类型与赋值" class="headerlink" title="子类型与赋值"></a>子类型与赋值</h3><p>目前为止, 我们使用了兼容性, 它在语言规范里没有定义. 在TypeScriptli里, 有两种类型的兼容性: 子类型与赋值.<br>它们的不同点在于: 赋值扩展了子类型兼容,允许any赋值或从any取值和允许数字赋值给枚举类型或枚举类型赋值给数字.’</p><p>语言里的不同地方飞蛾使用了它们之中的机制. 实际上,类型兼容性是由赋值兼容性来控制的甚至implements 和enxtens里,<br><a href="https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md" target="_blank" rel="noopener">more information</a></p><p>THE END!</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Type-Compatibility&quot;&gt;&lt;a href=&quot;#Type-Compatibility&quot; class=&quot;headerlink&quot; title=&quot;Type Compatibility&quot;&gt;&lt;/a&gt;Type Compatibility&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://www.typescriptlang.org/docs/handbook/type-compatibility.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;handbook&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Introduction&lt;/strong&gt;&lt;br&gt;Type compatibility in TypeScript is based on structural subtyping. Structural typing is a way of relating types based solely on their members. This is in contrast with norminal typing. Consider the following code:&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;interface Named&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name:string;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name:string&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; p:Named;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Person();&lt;span class=&quot;comment&quot;&gt;//ok, because of structural typing.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="https://xiaoxiaocoder.github.io/categories/programming/"/>
    
      <category term="javascript" scheme="https://xiaoxiaocoder.github.io/categories/programming/javascript/"/>
    
      <category term="typescript" scheme="https://xiaoxiaocoder.github.io/categories/programming/javascript/typescript/"/>
    
    
      <category term="typescript" scheme="https://xiaoxiaocoder.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>[TypeScript 06]手册指南: 类型推断</title>
    <link href="https://xiaoxiaocoder.github.io/programming/javascript/typescript/2017-08-05-typescript-06-type-inference.html"/>
    <id>https://xiaoxiaocoder.github.io/programming/javascript/typescript/2017-08-05-typescript-06-type-inference.html</id>
    <published>2017-08-05T10:50:02.000Z</published>
    <updated>2017-12-09T06:32:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这节介绍TypeScript里的类型推断. 即,类型是在哪里如何被推断的.</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>TypeScript里, 在有些没有明确制定出类型的地方,类型推断论hi帮助提供类型. 如下例子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x=<span class="number">3</span>;</span><br></pre></td></tr></table></figure></p><p>变量x的类型被推断为数字. 这种推断发生在初始化变量和成员, 设置默认参数值和决定函数返回值时.</p><a id="more"></a><h2 id="最佳通用类型"><a href="#最佳通用类型" class="headerlink" title="最佳通用类型"></a>最佳通用类型</h2><p>当需要从几个表达式中推断类型时,会使用这些表达式的类型来推断出一个最合适的通用类型. 如:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x=[<span class="number">0</span>,<span class="number">1</span>,<span class="literal">null</span>]</span><br></pre></td></tr></table></figure></p><p>为了推断x的类型,我们必须考虑所欲元素的类型. 这里有两种选择:number 和null. 计算通用类型算法会考虑所有的候选类型, 并给出一个兼容所有候选类型的类型.<br>由于最终的通用类型取自候选类型,有时候候选类型共享相同的通用类型,但是却没有一个类型能够Wie所有候选类型的类型. 例如:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> zoo=[<span class="keyword">new</span> Rhino(),<span class="keyword">new</span> Elephant(),<span class="keyword">new</span> Snake()];</span><br></pre></td></tr></table></figure></p><p>这里,我们想让zoo被推断为Animal[]类型, 但是这个数组里有没对象是Animal类型的. 因此不能推断出这个结果. 为了更正,当候选类型不能使用的时候我们需要明确的指出类型:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> zoo :Animal[] =[<span class="keyword">new</span> Rhino(),<span class="keyword">new</span> Elephane(), <span class="keyword">new</span> Snake()]</span><br></pre></td></tr></table></figure></p><p>如果没有找到最佳通用类型的话,类型推断的结果是空对象类型:{}. 因为这个类型没有任何成员,所以访问其成员的时候回报错.</p><h3 id="上下文类型"><a href="#上下文类型" class="headerlink" title="上下文类型"></a>上下文类型</h3><p>TypeScript类型推断也可能按照相反的方向进行. 这被叫做”按上下文归类”. 按上下文归类会发生在表达式的类型与所处的位置相关时. 如:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onmousedown =<span class="function"><span class="keyword">function</span>(<span class="params">mouseEvent</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(mouseEvent.button); <span class="comment">//&lt;-Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>TypeScript类型检查器使用Window.onmousedown函数的类型来推断右边函数表达式的类型. 因此,就能推断出mouseEvent参数的类型了. 如果函数表达式不是在上下文类型的位置,mouseEvent参数的类型需要指定为any. 这样也不会报错了.</p><p>如果上下文类型表达式包含了明确的类型信息, 上下文的类型被忽略. 重写上面的例子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onmusedown=<span class="function"><span class="keyword">function</span>(<span class="params">mouseEvent:any</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(mouseEvnet.button); <span class="comment">//&lt;-- Now, no error is given</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个函数表达式有明确的参数类型注解,上下文类型被忽略. 这样的话就不报错了, 因为这里不会使用到上下文类型.</p><p>上下文归类会在很多情况下使用的. 通常包含函数的参数, 赋值表达式的右边, 类型断言, 对象成员和数组字面量和返回值语句. 上下文类型也会做为最佳统统类型的候选类型. 如:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function createZoo():Animal[]&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">new</span> Rhino(),<span class="keyword">new</span> Elephant(),<span class="keyword">new</span> Snake()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个例子中,最佳通用类型有4个候选者,Animal,Rhino,Elephant,Snake. 当然,Animal会被作为最佳通用类型.</p><p>The End!</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;这节介绍TypeScript里的类型推断. 即,类型是在哪里如何被推断的.&lt;/p&gt;
&lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h2&gt;&lt;p&gt;TypeScript里, 在有些没有明确制定出类型的地方,类型推断论hi帮助提供类型. 如下例子:&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; x=&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;变量x的类型被推断为数字. 这种推断发生在初始化变量和成员, 设置默认参数值和决定函数返回值时.&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="https://xiaoxiaocoder.github.io/categories/programming/"/>
    
      <category term="javascript" scheme="https://xiaoxiaocoder.github.io/categories/programming/javascript/"/>
    
      <category term="typescript" scheme="https://xiaoxiaocoder.github.io/categories/programming/javascript/typescript/"/>
    
    
      <category term="typescript" scheme="https://xiaoxiaocoder.github.io/tags/typescript/"/>
    
      <category term="type-inference" scheme="https://xiaoxiaocoder.github.io/tags/type-inference/"/>
    
  </entry>
  
  <entry>
    <title>[TypeScript 05]手册指南: 枚举</title>
    <link href="https://xiaoxiaocoder.github.io/programming/javascript/typescript/2017-08-05-typescript-05-enums.html"/>
    <id>https://xiaoxiaocoder.github.io/programming/javascript/typescript/2017-08-05-typescript-05-enums.html</id>
    <published>2017-08-05T09:41:27.000Z</published>
    <updated>2017-12-09T06:32:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>使用枚举可以定义一些有名字的数字常量<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Direction&#123;</span><br><span class="line">    Up=<span class="number">1</span>,</span><br><span class="line">    Down=<span class="number">2</span>,</span><br><span class="line">    Left=<span class="number">3</span>,</span><br><span class="line">    Right=<span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一个枚举类型可以包含零个或多个枚举成员. 枚举成员具有一个数字值,它可以是常熟或是计算得出的值.当满足如下条件时,枚举成员被当做是常数:</p><ul><li>不具有初始化函数并且之前的枚举成员是常数. 在这种情况下,当前枚举成员的值为上一个枚举成员的值加1. 但是第一个美居元素是个例外. 如果它没有初始化方法,name它的初始化为0.</li></ul><a id="more"></a><ul><li>枚举成员使用常数枚举表达式初始化.常数枚举表达式是TypeScript表达式的子集,它可以在编译阶段求值.当一个表达式满足下面条件之一时,它就是一个常数枚举表达式:<ul><li>数字字面量</li><li>引用之前定义的常数枚举成员(可以是在不同的枚举类型中定义的) 如果这个成员是在同一个枚举类型中定义的,可以使用非限定名来引用.</li><li>带括号的常数枚举表达式</li><li>+,-,~一元运算符应用于常数枚举表达式</li><li>+,-,*,/,%,&lt;&lt;,&gt;&gt;,&gt;&gt;&gt;,&amp;,|,^二元运算符. 常数枚举表达式作为起一个操作对象, 若常数枚举表达式求值后为NaN或Infinity, 则会在编译节阶段报错.</li></ul></li></ul><p>所有其他情况的枚举成员被当做是需要计算得出的值.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enum FileAccess&#123;</span><br><span class="line">    <span class="comment">//constant members</span></span><br><span class="line">    None,</span><br><span class="line">    Read    =<span class="number">1</span>&lt;&lt;<span class="number">1</span>,</span><br><span class="line">    Write   =<span class="number">1</span>&lt;&lt;<span class="number">2</span>,</span><br><span class="line">    ReadWrite   = Read | Write,</span><br><span class="line">    <span class="comment">//computed member</span></span><br><span class="line">    G = <span class="string">"123"</span>.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>枚举是在运行时真正存在的一个对象. 其中一个原因是因为这样可以从枚举值到枚举名进行反向映射.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">enum Enum&#123;</span><br><span class="line">    A</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a=Enum.A;</span><br><span class="line"><span class="keyword">let</span> nameOfA=Enum[Enum.A]; <span class="comment">//"A"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//编译后</span></span><br><span class="line"><span class="keyword">var</span> Enum;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">Enum</span>)</span>&#123;</span><br><span class="line">    Enum[Enum[<span class="string">"A"</span>]=<span class="number">0</span>]=<span class="string">"A"</span>;</span><br><span class="line">&#125;)(Enum || Enum=&#123;&#125;)</span><br></pre></td></tr></table></figure></p><p>生成的代码中,枚举类型被编译成一个对象, 它包含双向映射(name-&gt;value) 和(value-&gt;name). 引用枚举成员总会生成一次属性访问并且永远不会内联. 多数情况下这是很好并且正确的解决方案. 然而有时当访问枚举值时,为了避免生成多余的代码和间接引用,可以使用常数枚举. 常数枚举实在enum前使用const修饰符<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> enum Enum&#123;</span><br><span class="line">    A=<span class="number">1</span>,</span><br><span class="line">    B=A*<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>常数枚举只能使用常数枚举表达式并且不同于常规的枚举的是它们在编译节阶段会被删除. 常数枚举成员在使用的地方呗内联进来,这是因为枚举成员不可能有计算成员.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> enum Directions&#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> directions=[Directions.Up,Directions.Down,Directions.Left,Directions.Right]</span><br></pre></td></tr></table></figure></p><p>生成后的代码为:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> directions=[<span class="number">0</span><span class="comment">/*Up*/</span>,<span class="number">1</span><span class="comment">/*Down*/</span>,<span class="number">2</span><span class="comment">/*Left*/</span>,<span class="number">3</span><span class="comment">/*Right*/</span>];</span><br></pre></td></tr></table></figure></p><h2 id="外部枚举"><a href="#外部枚举" class="headerlink" title="外部枚举"></a>外部枚举</h2><p>外部枚举用来描述已经存在的枚举类型的形状.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">declare enum Enum&#123;</span><br><span class="line">    A=<span class="number">1</span>,</span><br><span class="line">    B,</span><br><span class="line">    C=<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>外部枚举和非外部枚举之间有一个重要的区别,在正常的枚举里,没有初始化方法的成员被当成常数成员. 对于常数的外部枚举而言,没有初始化方法时被当做需要经过计算的.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;枚举&quot;&gt;&lt;a href=&quot;#枚举&quot; class=&quot;headerlink&quot; title=&quot;枚举&quot;&gt;&lt;/a&gt;枚举&lt;/h2&gt;&lt;p&gt;使用枚举可以定义一些有名字的数字常量&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;enum Direction&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Up=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Down=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Left=&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Right=&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;一个枚举类型可以包含零个或多个枚举成员. 枚举成员具有一个数字值,它可以是常熟或是计算得出的值.当满足如下条件时,枚举成员被当做是常数:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不具有初始化函数并且之前的枚举成员是常数. 在这种情况下,当前枚举成员的值为上一个枚举成员的值加1. 但是第一个美居元素是个例外. 如果它没有初始化方法,name它的初始化为0.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="编程" scheme="https://xiaoxiaocoder.github.io/categories/programming/"/>
    
      <category term="javascript" scheme="https://xiaoxiaocoder.github.io/categories/programming/javascript/"/>
    
      <category term="typescript" scheme="https://xiaoxiaocoder.github.io/categories/programming/javascript/typescript/"/>
    
    
      <category term="typescript" scheme="https://xiaoxiaocoder.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>[TypeScript 04]手册指南: 泛型</title>
    <link href="https://xiaoxiaocoder.github.io/programming/javascript/typescript/2017-08-05-typescript-04-generics.html"/>
    <id>https://xiaoxiaocoder.github.io/programming/javascript/typescript/2017-08-05-typescript-04-generics.html</id>
    <published>2017-08-05T01:23:07.000Z</published>
    <updated>2017-12-09T06:32:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>在像c#和java这样的语言中,可以使用<strong>泛型</strong>来创建可重用的组件,一个组件可以支持多种类型的数据. 这样的用户就可以以自己的数据类型来使用组件.</p><h2 id="泛型之Hello-world"><a href="#泛型之Hello-world" class="headerlink" title="泛型之Hello world"></a>泛型之Hello world</h2><p>不使用泛型,声明如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>(<span class="params">arg:number</span>):<span class="title">number</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>(<span class="params">arg:any</span>):<span class="title">any</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用泛型后<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg:T</span>):<span class="title">T</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>T帮助我们捕获用户传入的类型(如:number). 定义泛型后,使用如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> output=identity&lt;string&gt;(<span class="string">"afffsf"</span>); <span class="comment">//type of output will be string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//利用类型推断 -- 即编译器会根据传入的参数自动地帮我们确定T的类型</span></span><br><span class="line"><span class="keyword">let</span> output=identity(<span class="string">'mystring'</span>); <span class="comment">//type of output will be string</span></span><br></pre></td></tr></table></figure></p><h2 id="使用泛型变量"><a href="#使用泛型变量" class="headerlink" title="使用泛型变量"></a>使用泛型变量</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg:T</span>):<span class="title">T</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length); <span class="comment">// error:T doesn't have .length</span></span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入的可能是数字,但是数字没有.length属性. 正确如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function loggingIdentity&lt;T&gt;(arg:T[]):T[]&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length); <span class="comment">//array has a.length, so no more error</span></span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg:Array&lt;T&gt;</span>):<span class="title">Array</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length); <span class="comment">//Array has a.length, so no more error</span></span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h2><p>泛型函数的类型与非泛型函数的类型没什么不同,只是有一个类型参数在最前面,像函数声明一样:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg:T</span>):<span class="title">T</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity:<span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span>(arg:T)=&gt;T=identity;</span></span><br><span class="line"><span class="xml">//or</span></span><br><span class="line">let myIdentity:&lt;U&gt;(arg:U)=&gt;U=identity;</span><br><span class="line">//or</span><br><span class="line">let myIdentity:&#123;&lt;T&gt;(arg:T):T&#125;=identity;</span><br></pre></td></tr></table></figure></p><p>一个泛型接口.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface GenericIdentityFn&#123;</span><br><span class="line">    &lt;T&gt;(arg:T):T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg:T</span>):<span class="title">T</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity:GenericIdentityFn=identity;</span><br></pre></td></tr></table></figure></p><p>一个相似的例子,我们可能想把泛型翻出当做整个接口的一个参数. 这样我们就能清楚的知道使用的具体哪个泛型参数(如:Dictionary<string>而不是Dictionary). 这样接口里的其他陈冠也能知道这个参数的类型了.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface GenericIdentityFn&lt;T&gt;&#123;</span><br><span class="line">    (arg:T):T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg:T</span>):<span class="title">T</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myIdentity:GenericIdentityFn&lt;number&gt;=identity;</span><br></pre></td></tr></table></figure></string></p><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericNumber</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    zeroValue:T;</span><br><span class="line">    add:<span class="function">(<span class="params">x:T,y:T</span>)=&gt;</span>T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myGenericNumber=<span class="keyword">new</span> GenericNumber&lt;number&gt;();</span><br><span class="line">myGenericNumber.zeroVlaue=<span class="number">0</span>;</span><br><span class="line">myGenericNumber.add=<span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;<span class="keyword">return</span> x+y;&#125;;</span><br></pre></td></tr></table></figure><h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg:T</span>):<span class="title">T</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length);<span class="comment">//error: t doesn't have .length</span></span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比于操作any所有类型,我们想要限制函数去处理任意带有.length属性的所有类型.<strong>为此,我们定义一个接口来描述约束条件. 创建一个包含.length属性的接口,使用这个接口和extends关键字还实现约束:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface Lengthwise&#123;</span><br><span class="line">    legth:number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Lengthwise</span>&gt;(<span class="params">arg:T</span>):<span class="title">T</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.legth); <span class="comment">//now we know it has a .length property. so no more error.</span></span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loggingIdentity(<span class="number">3</span>); <span class="comment">//error, number doesn't have a .length property</span></span><br><span class="line">loggingIdentity(&#123;<span class="attr">length</span>:<span class="number">10</span>,<span class="attr">value</span>:<span class="number">3</span>&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="在泛型约束中使用参数参数"><a href="#在泛型约束中使用参数参数" class="headerlink" title="在泛型约束中使用参数参数"></a>在泛型约束中使用参数参数</h4><p>你可以声明一个类型参数,且它被另一个类型参数所约束. 如, 我哦们想要用属性名从对象里获取这个属性. 并且想要确保这个属性存在与对象obj上,因此我们需要在这个类型之间使用约束.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProperty</span>(<span class="params">obj:T, key:K</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x=&#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>,<span class="attr">c</span>:<span class="number">3</span>,<span class="attr">d</span>:<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">getProperty(x,<span class="string">"a"</span>); <span class="comment">//okay</span></span><br><span class="line">getProperty(x,<span class="string">"m"</span>); <span class="comment">//error, Argument of type 'm' isn't assignable to 'a'|'b'|'c'|'d'</span></span><br></pre></td></tr></table></figure></p><h4 id="在泛型里使用类类型"><a href="#在泛型里使用类类型" class="headerlink" title="在泛型里使用类类型"></a>在泛型里使用类类型</h4><p>在TypeScript使用泛型创建工厂函数时,需要引用构造函数的类类型. 如:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>&lt;<span class="title">T</span>&gt;(<span class="params">c:&#123;new(</span>):<span class="title">T</span>&#125;):<span class="title">T</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> c();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>更高级的例子, 使用原型属性推断并约束构造函数与类实例的关系<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeeKeeper</span></span>&#123;</span><br><span class="line">    hasMask:boolean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZooKeeper</span></span>&#123;</span><br><span class="line">    nametag:string;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    numLegs:number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bee</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    keeper:BeeKeeper;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lion</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    keeper:ZooKeeper;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createInstance</span>&lt;<span class="title">A</span> <span class="title">extends</span> <span class="title">Animal</span>&gt;(<span class="params">c:new(</span>)=&gt;<span class="title">A</span>):<span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> c();</span><br><span class="line">&#125;</span><br><span class="line">createInstance(Lion).keeper.nametag; <span class="comment">//typechecks!</span></span><br><span class="line">createInstance(Bee).keeper.hasMask; <span class="comment">//typechecks!</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;泛型&quot;&gt;&lt;a href=&quot;#泛型&quot; class=&quot;headerlink&quot; title=&quot;泛型&quot;&gt;&lt;/a&gt;泛型&lt;/h1&gt;&lt;p&gt;在像c#和java这样的语言中,可以使用&lt;strong&gt;泛型&lt;/strong&gt;来创建可重用的组件,一个组件可以支持多种类型的数据. 这样的用户就可以以自己的数据类型来使用组件.&lt;/p&gt;
&lt;h2 id=&quot;泛型之Hello-world&quot;&gt;&lt;a href=&quot;#泛型之Hello-world&quot; class=&quot;headerlink&quot; title=&quot;泛型之Hello world&quot;&gt;&lt;/a&gt;泛型之Hello world&lt;/h2&gt;&lt;p&gt;不使用泛型,声明如下&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;identity&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;arg:number&lt;/span&gt;):&lt;span class=&quot;title&quot;&gt;number&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; arg;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//or&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;identity&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;arg:any&lt;/span&gt;):&lt;span class=&quot;title&quot;&gt;any&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; arg;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;使用泛型后&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;identity&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;T&lt;/span&gt;&amp;gt;(&lt;span class=&quot;params&quot;&gt;arg:T&lt;/span&gt;):&lt;span class=&quot;title&quot;&gt;T&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; arg;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="https://xiaoxiaocoder.github.io/categories/programming/"/>
    
      <category term="javascript" scheme="https://xiaoxiaocoder.github.io/categories/programming/javascript/"/>
    
      <category term="typescript" scheme="https://xiaoxiaocoder.github.io/categories/programming/javascript/typescript/"/>
    
    
      <category term="typescript" scheme="https://xiaoxiaocoder.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>[TypeScript 03]手册指南: 函数</title>
    <link href="https://xiaoxiaocoder.github.io/programming/javascript/typescript/2017-08-03-typescript-03-function.html"/>
    <id>https://xiaoxiaocoder.github.io/programming/javascript/typescript/2017-08-03-typescript-03-function.html</id>
    <published>2017-08-03T15:00:00.000Z</published>
    <updated>2017-12-09T06:32:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>命名函数和匿名函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//named function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//anoymous function</span></span><br><span class="line"><span class="keyword">var</span> func=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><h4 id="为函数定义类型"><a href="#为函数定义类型" class="headerlink" title="为函数定义类型"></a>为函数定义类型</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x:number,y:number</span>):<span class="title">number</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myAdd=<span class="function"><span class="keyword">function</span>(<span class="params">x:number,y:number</span>):<span class="title">number</span></span>&#123;<span class="keyword">return</span> x+y&#125;</span><br></pre></td></tr></table></figure><p>我们可以为每个参数添加类型之后再为函数本身添加返回值类型. TypeScript能够根据返回语句自动推断出返回值类型,因此我们通常省略它.</p><a id="more"></a><h4 id="书写完整函数类型"><a href="#书写完整函数类型" class="headerlink" title="书写完整函数类型"></a>书写完整函数类型</h4><p>函数类型包含两部分:参数类型和返回值类型<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myAdd:<span class="function">(<span class="params">basex:number,basey:number</span>)=&gt;</span>number=<span class="function"><span class="keyword">function</span>(<span class="params">x:number,y:number</span>):<span class="title">number</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="推断类型"><a href="#推断类型" class="headerlink" title="推断类型"></a>推断类型</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//myadd has the full function type</span></span><br><span class="line"><span class="keyword">let</span> myAdd=<span class="function"><span class="keyword">function</span>(<span class="params">x:number,y:number</span>):<span class="title">number</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//The parameter 'x' and 'y' have the type number</span></span><br><span class="line"><span class="keyword">let</span> myAdd:<span class="function">(<span class="params">basex:number,basey:number</span>)=&gt;</span>number=<span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可选参数和默认参数"><a href="#可选参数和默认参数" class="headerlink" title="可选参数和默认参数"></a>可选参数和默认参数</h4><p>TypeScript里每个函数参数都是必须的. 这不指传递<strong>null</strong>或<strong>undefined</strong>作为参数,而是说编译器检查用书是否为每个参数都传入了值. 编译器还会假设只有这些参数会被传递进函数,(传递给一个函数的参数个数必须与函数期望的参数个数一致)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstname:string,lastname:string</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstname+<span class="string">' '</span>+lastname;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1=buildName(<span class="string">'bob'</span>); <span class="comment">//error, too few parameters</span></span><br><span class="line"><span class="keyword">let</span> result2=buildName(<span class="string">'bob'</span>,<span class="string">'adams'</span>,<span class="string">'sr.'</span>)<span class="comment">//error, too many parameters</span></span><br><span class="line"><span class="keyword">let</span> result3=buildName(<span class="string">'bob'</span>,<span class="string">'adams'</span>);<span class="comment">//ah, just right</span></span><br></pre></td></tr></table></figure></p><p>TypeScript中,可以在function中参数名加”?”实现可选参数功能.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">firstname:string,lastname?:string</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>可选参数必须放在必须参数后面</strong><br>在TypeScript里, 可以为参数提供一个默认值当用户没有传递该参数或传入的值是<strong>undefined</strong>时, 该参数叫做默认参数.</p><p>可选参数和默认参数共享数据类型<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstname:string,lastName?:string</span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstname:string,lastname=<span class="string">"smith"</span></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p><strong>与普通可选参数不同的是,待默认值的参数不需要放在必须参数的后面. 如果带默认值的参数出现在必须参数签名,用户必须明确的传入 undefinde 值来获得默认值.</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstname=<span class="string">"will"</span>,lastname:string</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstname+<span class="string">" "</span>+lastname;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1=buildName(<span class="string">'bob'</span>); <span class="comment">//error, too few parameters;</span></span><br><span class="line"><span class="keyword">let</span> result2=buildName(<span class="string">'bob'</span>,<span class="string">'adams'</span>,<span class="string">'sr.'</span>);<span class="comment">//error, too many parameters</span></span><br><span class="line"><span class="keyword">let</span> result3=buildName(<span class="string">'bob'</span>,<span class="string">'adams'</span>); <span class="comment">//okay and returns 'bob adams'</span></span><br><span class="line"><span class="keyword">let</span> result4=buildName(<span class="literal">undefined</span>,<span class="string">'adams'</span>);</span><br><span class="line"><span class="comment">//okay and returns 'will adams'</span></span><br></pre></td></tr></table></figure></p><h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><p>必要参数.<br>默认参数和可选参数共同点: 它们表示某一个参数. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstname:string, ...restofName:string[]</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstname+<span class="string">" "</span>+restofName.join(<span class="string">' '</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employeeName=buildName(<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>);</span><br></pre></td></tr></table></figure><p>剩余参数会被当做个数不限的可选参数. 可以一个都没有,也可以有任意多个.</p><h2 id="this-vs-箭头函数"><a href="#this-vs-箭头函数" class="headerlink" title="this vs 箭头函数"></a>this vs 箭头函数</h2><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p><a href="http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/" target="_blank" rel="noopener">UNDESTANDING JAVASCRIPT FUNCTION INVOCATION and this</a></p><h3 id="this-和-箭头函数"><a href="#this-和-箭头函数" class="headerlink" title="this 和 箭头函数"></a>this 和 箭头函数</h3><p>javascript里, this的值在函数被调用的时候才会指定.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> deck=&#123;</span><br><span class="line">    suits:[<span class="string">'hearts'</span>,<span class="string">'spades'</span>,<span class="string">'clubs'</span>,<span class="string">'diamonds'</span>],</span><br><span class="line">    cards: <span class="built_in">Array</span>(<span class="number">52</span>),</span><br><span class="line">    createCardPicker: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> pickedCard=<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">52</span>);</span><br><span class="line">            <span class="keyword">let</span> pickedSuit=<span class="built_in">Math</span>.floor(pickedCard/<span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                suit:<span class="keyword">this</span>.suits[pickedSuit],</span><br><span class="line">                card:pickedCard %<span class="number">13</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cardPicker =deck.crateCardPicker();</span><br><span class="line"><span class="keyword">let</span> pickedCard=cardPicker();</span><br><span class="line"></span><br><span class="line">alert(<span class="string">'card:'</span>+pickedCard.card+<span class="string">' of '</span>+ pickedCard.suit)</span><br></pre></td></tr></table></figure></p><p>运行时,并未弹框而是报错, 因为 this被这设置成window. 顶级的非方法式调用hi将this视为window.(严格模式下,this 为undefined)</p><p><strong>箭头函数</strong>可以保存函数创建时的this值,而不是调用时的值.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> deck=&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    createCardPicker:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//<span class="doctag">NOTE:</span> the line beloew is now an arrow function, allowing us to capture 'this' right here.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>更好事情是，TypeScript会警告你犯了一个错误，<br>如果你给编译器设置了–noImplicitThis标记。 它会指出 this.suits[pickedSuit]里的this的类型为any。</p><h3 id="this参数"><a href="#this参数" class="headerlink" title="this参数"></a>this参数</h3><p>不幸的是, this.suits[pickedSuit]的类型依旧为any. 这是因为this来之对象字面量里的函数表达式. 修改方法是,提供一个现实的thsi参数. this参数一个假的参数,它粗线在参数列表的最前面:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">this:void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//make sure this is unusable in this standalone function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>修改后:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">interface Card&#123;</span><br><span class="line">    suit: string,</span><br><span class="line">    card: number</span><br><span class="line">&#125;</span><br><span class="line">interface Deck&#123;</span><br><span class="line">    suits: string[],</span><br><span class="line">    cards: number[],</span><br><span class="line">    createCardPicker(<span class="keyword">this</span>:Deck):<span class="function"><span class="params">()</span>=&gt;</span>Card</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> deck:Deck=&#123;</span><br><span class="line">    suit:[],</span><br><span class="line">    card: <span class="built_in">Array</span>(<span class="number">52</span>),</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">    createCardPicker: <span class="function"><span class="keyword">function</span>(<span class="params">this: Deck</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> pickedCard= <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">52</span>);</span><br><span class="line">            <span class="keyword">let</span> pickedSuit=<span class="built_in">Math</span>.floor(pickedCard/<span class="number">13</span>);</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                suit: <span class="keyword">this</span>.suits[pickedSuit],</span><br><span class="line">                card: pickedCard %<span class="number">13</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在TypeScript知道createCardPicker期望在某个Deck对象上调用。 也就是说 this是Deck类型的，而非any，因此–noImplicitThis不会报错了。</p><h3 id="this参数在回调函数里"><a href="#this参数在回调函数里" class="headerlink" title="this参数在回调函数里"></a>this参数在回调函数里</h3><p>当你讲一个函数传递到某个库函数里稍后会被调用时, 因为当回调被调用的时候. 它们会被当成一个普通的函数调用. this将为undefined. 稍作改动,就可通过this参数来避免错误.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface UIElement&#123;</span><br><span class="line">    addClickListener(onclick:<span class="function">(<span class="params"><span class="keyword">this</span>:<span class="keyword">void</span>,e:Event</span>)=&gt;</span><span class="keyword">void</span>):<span class="keyword">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>this:void means that addClickListener expects onclick to be a function that does not require a this type. Second, annotate your calling code with this.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">    info:string,</span><br><span class="line">    onClickBad(<span class="keyword">this</span>: Handler, <span class="attr">e</span>:Event)&#123;</span><br><span class="line">        <span class="comment">//oops, use this here, using this callback wold crash at runtime</span></span><br><span class="line">        <span class="keyword">this</span>.info=e.message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> h=<span class="keyword">new</span> Handler();</span><br><span class="line">uiElement.addClickListener(h.onClickBad); <span class="comment">//error</span></span><br></pre></td></tr></table></figure><p>指定this类型后,你显示声明 onClickBad 必须在Handler的实例上调用. 然后TypeScript会检测到addClickListener要求函数带有this:void.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span></span>=&#123;</span><br><span class="line">    <span class="comment">//,,,</span></span><br><span class="line">    onClickGood(<span class="keyword">this</span>:<span class="keyword">void</span>,<span class="attr">e</span>:Event)&#123;</span><br><span class="line">        <span class="comment">//can't use this here because it's of type void</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为onClickGood指定了this类型为void,因此传递addClickListener是合法的. 当然意味着不能使用this.info, 如果两者都想要, 可以使用 箭头函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">    info:string,</span><br><span class="line">    onClick =(e:Event)-&gt;&#123;<span class="keyword">this</span>.info=e.message&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是可行的因为箭头函数不会捕获this, 所以你总是可以把他们传给期望this:void的函数.缺点是每个Handler对象都会创建一个箭头函数.<br>另一方面, 方法只会被创建一次, 添加到Handler的原型链上. 他们在不同的Handler对象间是共享的.</p><h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p>javascript里函数根据传入不同的参数而返回不同类型的数据是很常见的.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> suits= [<span class="string">'hearts'</span>,<span class="string">'spades'</span>,<span class="string">'clubs'</span>,<span class="string">'diamonds'</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x</span>):<span class="title">any</span></span>&#123;</span><br><span class="line">    <span class="comment">//check to see if we're working with an object/array</span></span><br><span class="line">    <span class="comment">//if so, they gave us the deck and we'll pick the card</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> x==<span class="string">"object"</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> pickedCard=<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*x.length);</span><br><span class="line">        <span class="keyword">return</span> pickedCard;</span><br><span class="line">    &#125;<span class="comment">//otherwise just let them pick the card</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> x ==<span class="string">"number"</span>)&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方法是为同意而个函数提供多个哈数类型定义了艾进行函数重载. 编译器会根据这个列表去处理函数的调用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> suits= [<span class="string">'hearts'</span>,<span class="string">'spades'</span>,<span class="string">'clubs'</span>,<span class="string">'diamonds'</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x:&#123;suit:string, card:number[]&#125;</span>) :<span class="title">number</span>;</span></span><br><span class="line"><span class="function"><span class="title">function</span> <span class="title">pickCard</span>(<span class="params">x:number</span>):</span>&#123;suit:string,<span class="attr">card</span>:number&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不是重载列表的一部分 因此这里只有两个重载：一个是接收对象另一个接收数字。 以其它参数调用 pickCard会产生错误。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x</span>):<span class="title">any</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> x==<span class="string">"object"</span>)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> x==<span class="string">"number"</span>)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了让编译器能够选择正确的检查类型, 它与javascript里的处理流程相似. 查找重载列表,尝试使用一个重载定义. 如果匹配的话就是使用这个. 因此, 在定义重载的时候,一定要把嘴精确的定义放在最前面.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h2&gt;&lt;p&gt;命名函数和匿名函数&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//named function&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;x,y&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; x+y;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//anoymous function&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; func=&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;函数类型&quot;&gt;&lt;a href=&quot;#函数类型&quot; class=&quot;headerlink&quot; title=&quot;函数类型&quot;&gt;&lt;/a&gt;函数类型&lt;/h3&gt;&lt;h4 id=&quot;为函数定义类型&quot;&gt;&lt;a href=&quot;#为函数定义类型&quot; class=&quot;headerlink&quot; title=&quot;为函数定义类型&quot;&gt;&lt;/a&gt;为函数定义类型&lt;/h4&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;x:number,y:number&lt;/span&gt;):&lt;span class=&quot;title&quot;&gt;number&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; x+y;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; myAdd=&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;x:number,y:number&lt;/span&gt;):&lt;span class=&quot;title&quot;&gt;number&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; x+y&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们可以为每个参数添加类型之后再为函数本身添加返回值类型. TypeScript能够根据返回语句自动推断出返回值类型,因此我们通常省略它.&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="https://xiaoxiaocoder.github.io/categories/programming/"/>
    
      <category term="javascript" scheme="https://xiaoxiaocoder.github.io/categories/programming/javascript/"/>
    
      <category term="typescript" scheme="https://xiaoxiaocoder.github.io/categories/programming/javascript/typescript/"/>
    
    
      <category term="typescript" scheme="https://xiaoxiaocoder.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>VueJS 开发常见问题集锦</title>
    <link href="https://xiaoxiaocoder.github.io/programming/2017-07-31-vuejs-common-issues.html"/>
    <id>https://xiaoxiaocoder.github.io/programming/2017-07-31-vuejs-common-issues.html</id>
    <published>2017-07-31T05:13:44.000Z</published>
    <updated>2017-12-09T06:32:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="涉及技术栈"><a href="#涉及技术栈" class="headerlink" title="涉及技术栈"></a>涉及技术栈</h2><ul><li>CLI: Vue-CLI</li><li>UI: Element</li><li>HTML: Pug(Jade)</li><li>CSS: Less</li><li>JavaScript: ES6</li></ul><hr><p>正文：</p><h3 id="polyfill-与-transform-runtime"><a href="#polyfill-与-transform-runtime" class="headerlink" title="polyfill 与 transform-runtime"></a>polyfill 与 transform-runtime</h3><p>首先，vue-cli 为我们自动添加了 babel-plugin-transform-runtime 这个插件，该插件多数情况下都运作正常，可以转换大部分 ES6 语法。<br>但是，存在如下两个问题：</p><ol><li>异步加载组件时，会产生 polyfill 代码冗余</li><li>不支持对全局函数与实例方法的 polyfill<br>　　两个问题的原因均归因于 babel-plugin-transform-runtime 采用了沙箱机制来编译我们的代码（即：不修改宿主环境的内置对象）。<a id="more"></a>　　由于异步组件最终会被编译为一个单独的文件，所以即使多个组件中使用了同一个新特性（例如：Object.keys()），那么在每个编译后的文件中都会有一份该新特性的 polyfill 拷贝。如果项目较小可以考虑不使用异步加载，但是首屏的压力会比较大。<br>　　不支持全局函数（如：Promise、Set、Map），Set 跟 Map 这两种数据结构应该大家用的也不多，影响较小。但是 Promise 影响可能就比较大了。<br>　　不支持实例方法（如：’abc’.include(‘b’)、[‘1’, ‘2’, ‘3’].find((n) =&gt; n &lt; 2) 等等），这个限制几乎废掉了大部分字符串和一半左右数组的新特性。</li></ol><blockquote><p>一般情况下 babel-plugin-transform-runtime 能满足大部分的需求，当不满足需求时，推荐使用完整的 babel-polyfill。</p></blockquote><h4 id="替换-babel-polyfill"><a href="#替换-babel-polyfill" class="headerlink" title="替换 babel-polyfill"></a>替换 babel-polyfill</h4><ol><li>首先，从项目中移除 babel-plugin-transform-runtime</li><li><p>卸载该依赖：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">npm un babel-plugin-transform-runtime -D</span><br><span class="line">　　修改 babel 配置文件</span><br><span class="line"></span><br><span class="line"><span class="comment">// .babelrc</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="string">"plugins"</span>: [</span><br><span class="line">    <span class="comment">// - "transform-runtime"</span></span><br><span class="line">  ]</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后，安装 babel-polyfill 依赖：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm i babel-polyfill -D</span><br><span class="line"><span class="string">``</span><span class="string">`　　</span></span><br><span class="line"><span class="string">4. 最后，在入口文件中导入</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="comment">// src/main.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'babel-polyfill'</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="ES6-import-引用问题"><a href="#ES6-import-引用问题" class="headerlink" title="ES6 import 引用问题"></a>ES6 import 引用问题</h3><p>　　在 ES6 中，模块系统的导入与导出采用的是引用导出与导入（非简单数据类型），也就是说，如果在一个模块中定义了一个对象并导出，在其他模块中导入使用时，导入的其实是一个变量引用（指针），如果修改了对象中的属性，会影响到其他模块的使用。<br>　　通常情况下，系统体量不大时，我们可以使用 JSON.parse(JSON.stringify(str)) 简单粗暴地来生成一个全新的深度拷贝的 数据对象。不过当组件较多、数据对象复用程度较高时，很明显会产生性能问题，这时我们可以考虑使用 Immutable.js。</p><p>鉴于这个原因，进行复杂数据类型的导出时，需要注意多个组件导入同一个数据对象时修改数据后可能产生的问题。<br>此外，模块定义变量或函数时即便使用 let 而不是 const，在导入使用时都会变成只读，不能重新赋值，效果等同于用 const 声明。</p><h3 id="在-Vue-中使用-Pug-与-Less"><a href="#在-Vue-中使用-Pug-与-Less" class="headerlink" title="在 Vue 中使用 Pug 与 Less"></a>在 Vue 中使用 Pug 与 Less</h3><p>####安装依赖<br>Vue 中使用 vue-loader 根据 lang 属性自动判断所需要的 loader，所以不用额外配置 Loader，但是需要手动安装相关依赖：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i pug -D</span><br><span class="line">npm i less-loader -D</span><br></pre></td></tr></table></figure></p><p>还是相当方便的，不用手动修改 webpack 的配置文件添加 loader 就可以使用了</p><blockquote><p>使用 pug 还是 pug-loader？sass 两种语法的 loader 如何设置？ — 请参考 预处理器 · vue-loader</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- xxx.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"less"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.action</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">color</span>: <span class="selector-id">#ddd</span>;</span></span><br><span class="line"><span class="undefined">      ul &#123;</span></span><br><span class="line"><span class="undefined">        overflow: hidden;</span></span><br><span class="line"><span class="undefined">        li &#123;</span></span><br><span class="line"><span class="undefined">          float: left;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">lang</span>=<span class="string">"pug"</span>&gt;</span></span><br><span class="line">  .action(v-if='hasRight')</span><br><span class="line">    ul</span><br><span class="line">      li 编辑</span><br><span class="line">      li 删除</span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="undefined">    data () &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        hasRight: <span class="literal">true</span></span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="定义全局函数或变量"><a href="#定义全局函数或变量" class="headerlink" title="定义全局函数或变量"></a>定义全局函数或变量</h3><p>　　许多时候我们需要定义一些全局函数或变量，来处理一些频繁的操作（这里拿 AJAX 的异常处理举例说明）。但是在 Vue 中，每一个单文件组件都有一个独立的上下文（this）。通常在异常处理中，需要在视图上有所体现，这个时候我们就需要访问 this 对象，但是全局函数的上下文通常是 window，这时候就需要一些特殊处理了。</p><h4 id="简单粗暴型"><a href="#简单粗暴型" class="headerlink" title="简单粗暴型"></a>简单粗暴型</h4><p>　　最简单的方法就是直接在 window 对象上定义一个全局方法，在组件内使用的时候用 bind、call 或 apply 来改变上下文。<br>　　定义一个全局异常处理方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// errHandler.js</span></span><br><span class="line"><span class="built_in">window</span>.errHandler = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 不能使用箭头函数</span></span><br><span class="line">  <span class="keyword">if</span> (err.code &amp;&amp; err.code !== <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$store.commit(<span class="string">'err'</span>, <span class="literal">true</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在入口文件中导入：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'errHandler.js'</span></span><br></pre></td></tr></table></figure></p><p>在组件中使用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xxx.vue</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="keyword">this</span>.errHandler = <span class="built_in">window</span>.errHandler.bind(<span class="keyword">this</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  method: &#123;</span><br><span class="line">    getXXX () &#123;</span><br><span class="line">      <span class="keyword">this</span>.$http.get(<span class="string">'xxx/xx'</span>).then(<span class="function">(<span class="params">&#123; body: result &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (result.code === <span class="number">200</span>) &#123;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.errHandler(result)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;).catch(<span class="keyword">this</span>.errHandler)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="优雅安全型"><a href="#优雅安全型" class="headerlink" title="优雅安全型"></a>优雅安全型</h4><p>在大型多人协作的项目中，污染 window 对象还是不太妥当的。特别是一些比较有个人特色的全局方法（可能在你写的组件中几乎处处用到，但是对于其他人来说可能并不需要）。这时候推荐写一个模块，更优雅安全，也比较自然，唯一不足之处就是每个需要使用该函数或方法的组件都需要进行导入。<br>　　使用方法与前一种大同小异，就不多作介绍了。￣ω￣=</p><h3 id="Moment-JS-与-Webpack"><a href="#Moment-JS-与-Webpack" class="headerlink" title="Moment.JS 与 Webpack"></a>Moment.JS 与 Webpack</h3><p>　　在使用 Moment.js 遇到一些问题，发现最终打包的文件中将 Moment.js 的全部语言包都打包了，导致最终文件徒然增加 100+kB。查了一下，发现可能是 webpack 打包或是 Moment.js 资源引用问题（?），目前该问题还未被妥善处理，需要通过一些 trick 来解决这个问题。<br>　　在 webpack 的生产配置文件中的 plugins 字段中添加一个插件，使用内置的方法类 ContextReplacementPlugin 过滤掉 Moment.js 中那些用不到的语言包：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// build/webpack.prod.conf.js</span></span><br><span class="line"><span class="keyword">new</span> webpack.ContextReplacementPlugin(<span class="regexp">/moment[\\/]locale$/</span>, /^\.\/(zh-cn)$/)</span><br></pre></td></tr></table></figure></p><p>解决方案采自 oleg-nogin@webpack/webpack#3128。<br>问题讨论详见 GitHub Issue: moment/moment#2373、webpack/webpack#3128。</p><h3 id="自定义路径别名"><a href="#自定义路径别名" class="headerlink" title="自定义路径别名"></a>自定义路径别名</h3><p>　　可能有些人注意到了，在 vue-cli 生成的模板中在导入组件时使用了这样的语法：</p><p>import Index from ‘@/components/Index’<br>　　这个 @ 是什么东西？后来改配置文件的时候发现这个是 webpack 的配置选项之一：路径别名。<br>　　我们也可以在基础配置文件中添加自己的路径别名，比如下面这个就把 ~ 设置为路径 src/components 的别名：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// build/webpack.base.js</span></span><br><span class="line">&#123;</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: [<span class="string">'.js'</span>, <span class="string">'.vue'</span>, <span class="string">'.json'</span>],</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">'vue$'</span>: <span class="string">'vue/dist/vue.esm.js'</span>,</span><br><span class="line">      <span class="string">'@'</span>: resolve(<span class="string">'src'</span>),</span><br><span class="line">      <span class="string">'~'</span>: resolve(<span class="string">'src/components'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">　　然后我们导入组件的时候就可以这样写：</span><br><span class="line"></span><br><span class="line"><span class="comment">// import YourComponent from 'YourComponent'</span></span><br><span class="line"><span class="comment">// import YourComponent from './YourComponent'</span></span><br><span class="line"><span class="comment">// import YourComponent from '../YourComponent'</span></span><br><span class="line"><span class="comment">// import YourComponent from '/src/components/YourComponent'</span></span><br><span class="line"><span class="keyword">import</span> YourComponent <span class="keyword">from</span> <span class="string">'~/YourComponent'</span></span><br></pre></td></tr></table></figure></p><p>　　既解决了路径过长的麻烦，又解决了相对路径的烦恼，方便很多吧！ヾ(ﾟ∀ﾟゞ)</p><h3 id="CSS-作用域与模块"><a href="#CSS-作用域与模块" class="headerlink" title="CSS 作用域与模块"></a>CSS 作用域与模块</h3><p>组件内样式</p><p>　　通常，组件中 <style></style> 标签里的样式是全局的，在使用第三方 UI 库（如：Element）时，全局样式很可能影响 UI 库的样式。我们可以通过添加 scoped 属性来使 style 中的样式只作用于当前组件：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;style lang="less" scoped&gt;</span><br><span class="line">  @<span class="keyword">import</span> <span class="string">'other.less'</span>;</span><br><span class="line">  <span class="selector-class">.title</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.2rem</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><p>在有 scoped 属性的 style 标签内导入其他样式，同样会受限于作用域，变为组件内样式。复用程度较高的样式不建议这样使用。<br>另，在组件内样式中应避免使用元素选择器，原因在于元素选择器与属性选择器组合时，性能会大大降低。<br>— 两种组合选择器的测试：classes selector，elements selector</p><h4 id="导入样式"><a href="#导入样式" class="headerlink" title="导入样式"></a>导入样式</h4><p>　　相对于 style 使用 scoped 属性时的组件内样式，有时候我们也需要添加一些全局样式。当然我们可以用没有 scoped 属性的 style 来写全局样式。但是相比较，更推荐下面这种写法：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 单独的全局样式文件 */</span></span><br><span class="line"><span class="comment">/* style-global.less */</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.title</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.4rem</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bolder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后在入口文件中导入全局样式：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// src/main.js</span><br><span class="line">import 'style-global.less'</span><br></pre></td></tr></table></figure></p><h3 id="获取表单控件值"><a href="#获取表单控件值" class="headerlink" title="获取表单控件值"></a>获取表单控件值</h3><p>　　通常我们可以直接使用 v-model 将表单控件与数据进行绑定，但是有时候我们也会需要在用户输入的时候获取当前值（比如：实时验证当前输入控件内容的有效性）。</p><p>　　这时我们可以使用 @input 或 @change 事件绑定我们自己的处理函数，并传入 $event 对象以获取当前控件的输入值：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'text'</span> @<span class="attr">change</span>=<span class="string">'change($event)'</span>&gt;</span></span><br><span class="line">change (e) &#123;</span><br><span class="line">  let curVal = e.target.value</span><br><span class="line">  if (/^\d+$/.test(curVal)) &#123;</span><br><span class="line">    this.num = +curVal</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.error('%s is not a number!', curVal)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然，如果 UI 框架采用 Element 会更简单，它的事件回调会直接传入当前值。</p><h3 id="v-for-的使用-tips"><a href="#v-for-的使用-tips" class="headerlink" title="v-for 的使用 tips"></a>v-for 的使用 tips</h3><p>　　v-for 指令很强大，它不仅可以用来遍历数组、对象，甚至可以遍历一个数字或字符串。</p><p>　　基本语法就不讲了，这里讲个小 tips：</p><h4 id="索引值"><a href="#索引值" class="headerlink" title="索引值"></a>索引值</h4><p>　　在使用 v-for 根据对象或数组生成 DOM 时，有时候需要知道当前的索引。我们可以这样：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">'(item, key) in items'</span> <span class="attr">:key</span>=<span class="string">'key'</span>&gt;</span> &#123;&#123; key &#125;&#125; - &#123;&#123; item &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>　　但是，在遍历数字的时候需要注意，数字的 value 是从 1 开始，而 key 是从 0 开始：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">'(v, k) in 3'</span> <span class="attr">:key</span>=<span class="string">'k'</span>&gt;</span> &#123;&#123; k &#125;&#125;-&#123;&#123; v &#125;&#125; </span><br><span class="line">  <span class="comment">&lt;!-- output to be 0-1, 1-2, 2-3 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>2.2.0+ 的版本里，当在组件中使用 v-for 时，key 现在是必须的。</strong></p><h3 id="模板的唯一根节点"><a href="#模板的唯一根节点" class="headerlink" title="模板的唯一根节点"></a>模板的唯一根节点</h3><p>　　与 JSX 相同，组件中的模板只能有一个根节点，即下面这种写法是 错误 的：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">article</span>&gt;</span>Balabala...<span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>　　我们需要用一个块级元素把他包裹起来：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">article</span>&gt;</span>Balabala...<span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>原因参考：React-小记：组件开发注意事项#唯一根节点</p><h3 id="项目路径配置"><a href="#项目路径配置" class="headerlink" title="项目路径配置"></a>项目路径配置</h3><p>　　由于 vue-cli 配置的项目提供了一个内置的静态服务器，在开发阶段基本不会有什么问题。但是，当我们把代码放到服务器上时，经常会遇到静态资源引用错误，导致界面一片空白的问题。</p><p>　　这是由于 vue-cli 默认配置的 webpack 是以站点根目录引用的文件，然而有时候我们可能需要把项目部署到子目录中。</p><p>　　我们可以通过 config/index.js 来修改文件引用的相对路径：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">build.assetsSubDirectory: <span class="string">'static'</span></span><br><span class="line">build.assetsPublicPath: <span class="string">'/'</span></span><br><span class="line"></span><br><span class="line">dev.assetsSubDirectory: <span class="string">'static'</span></span><br><span class="line">dev.assetsPublicPath: <span class="string">'/'</span></span><br></pre></td></tr></table></figure></p><p>　　我们可以看到导出对象中 build 与 dev 均有 assetsSubDirectory、assetsPublicPath 这两个属性。</p><p>　　其中 assetsSubDirectory 指静态资源文件夹，也就是打包后的　js、css、图片等文件所放置的文件夹，这个默认一般不会有问题。</p><p>　　assetsPublicPath 指静态资源的引用路径，默认配置为 /，即网站根目录，与 assetsSubDirectory 组合起来就是完整的静态资源引用路径 /static。</p><p>　　写到这里解决方法已经很明显了，只要把根目录改为相对目录就好了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">build.assetsSubDirectory: <span class="string">'static'</span></span><br><span class="line">build.assetsPublicPath: <span class="string">'./'</span></span><br></pre></td></tr></table></figure></p><p><a href="https://segmentfault.com/a/1190000010230843" target="_blank" rel="noopener">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;涉及技术栈&quot;&gt;&lt;a href=&quot;#涉及技术栈&quot; class=&quot;headerlink&quot; title=&quot;涉及技术栈&quot;&gt;&lt;/a&gt;涉及技术栈&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;CLI: Vue-CLI&lt;/li&gt;
&lt;li&gt;UI: Element&lt;/li&gt;
&lt;li&gt;HTML: Pug(Jade)&lt;/li&gt;
&lt;li&gt;CSS: Less&lt;/li&gt;
&lt;li&gt;JavaScript: ES6&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;正文：&lt;/p&gt;
&lt;h3 id=&quot;polyfill-与-transform-runtime&quot;&gt;&lt;a href=&quot;#polyfill-与-transform-runtime&quot; class=&quot;headerlink&quot; title=&quot;polyfill 与 transform-runtime&quot;&gt;&lt;/a&gt;polyfill 与 transform-runtime&lt;/h3&gt;&lt;p&gt;首先，vue-cli 为我们自动添加了 babel-plugin-transform-runtime 这个插件，该插件多数情况下都运作正常，可以转换大部分 ES6 语法。&lt;br&gt;但是，存在如下两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;异步加载组件时，会产生 polyfill 代码冗余&lt;/li&gt;
&lt;li&gt;不支持对全局函数与实例方法的 polyfill&lt;br&gt;　　两个问题的原因均归因于 babel-plugin-transform-runtime 采用了沙箱机制来编译我们的代码（即：不修改宿主环境的内置对象）。
    
    </summary>
    
    
      <category term="vuejs" scheme="https://xiaoxiaocoder.github.io/tags/vuejs/"/>
    
  </entry>
  
  <entry>
    <title>[CSS3 温故] background</title>
    <link href="https://xiaoxiaocoder.github.io/programming/2017-07-27-css3-background.html"/>
    <id>https://xiaoxiaocoder.github.io/programming/2017-07-27-css3-background.html</id>
    <published>2017-07-27T07:12:54.000Z</published>
    <updated>2017-12-09T06:32:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><code>background: [&lt;bg-layer&gt;,]*</code></p><ul><li>background-color: 背景颜色</li><li>background-image: 背景图片</li><li>background-repeat: 重复方式</li><li>background-position:图像位置</li><li>background-size: 定义背景图像大小</li><li>background-clip: 裁剪方式(显示范围)</li><li>background-origin: 指定绘制背景起点</li><li>background-break: 指定内联的背景图像进行平铺时的循环方式</li><li>background-attachment: 定义背景图像的显示方式</li></ul><a id="more"></a><h3 id="绘制背景起始坐标-background-origin-指定background-position的参照点位置"><a href="#绘制背景起始坐标-background-origin-指定background-position的参照点位置" class="headerlink" title="绘制背景起始坐标 background-origin(指定background-position的参照点位置)"></a>绘制背景起始坐标 background-origin(指定background-position的参照点位置)</h3><ul><li>border-box: 从边框区域</li><li>padding-box : 默认,从补白区域</li><li>content-box:从内容区域</li></ul><h3 id="裁剪区域-background-clip"><a href="#裁剪区域-background-clip" class="headerlink" title="裁剪区域 background-clip"></a>裁剪区域 background-clip</h3><ul><li>border-box: 默认,从边框区域向外裁剪背景</li><li>padding-box: 从补白区域向外裁剪(边框部分的背景被裁剪掉)。</li><li>content-box: 从内容区域向外裁剪(补白区域,边框区域被裁剪)。</li></ul><blockquote><p>如果background-clip属性设置为padding,background-origin设置为border-box,且background-position设置为”top left”,则背景图片左上角将会被截取掉部分. <a href="http://www.cnblogs.com/2050/archive/2012/11/13/2768289.html" target="_blank" rel="noopener">background-origin vs background-clip</a></p></blockquote><h3 id="背景图像大小-background-size"><a href="#背景图像大小-background-size" class="headerlink" title="背景图像大小 background-size"></a>背景图像大小 background-size</h3><p><code>background-size:[&lt;length&gt; | &lt;percentage&gt; | auto]{1,2} | cover | contain</code></p><ul><li>length: 有浮点数和单位标识符组成的长度值. 不可为负值.</li><li>percentage: 取值为0%~100%之间的值. 不可为负值.</li><li>cover: 保持背景图像本身的宽高比,将图片缩放到正好完全覆盖所定义背景的区域</li><li>contain: 保持图像本身宽高比,将图片缩放到宽度或高度正好适应所定义背景的区域.</li></ul><h3 id="背景循环方式-background-break"><a href="#背景循环方式-background-break" class="headerlink" title="背景循环方式 background-break"></a>背景循环方式 background-break</h3><ul><li>bounding-box: 在整个背景区域平铺</li><li>each-box : 在每一行中平铺</li><li>continuous : 下一行紧接着上一行平铺</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;&lt;code&gt;background: [&amp;lt;bg-layer&amp;gt;,]*&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;background-color: 背景颜色&lt;/li&gt;
&lt;li&gt;background-image: 背景图片&lt;/li&gt;
&lt;li&gt;background-repeat: 重复方式&lt;/li&gt;
&lt;li&gt;background-position:图像位置&lt;/li&gt;
&lt;li&gt;background-size: 定义背景图像大小&lt;/li&gt;
&lt;li&gt;background-clip: 裁剪方式(显示范围)&lt;/li&gt;
&lt;li&gt;background-origin: 指定绘制背景起点&lt;/li&gt;
&lt;li&gt;background-break: 指定内联的背景图像进行平铺时的循环方式&lt;/li&gt;
&lt;li&gt;background-attachment: 定义背景图像的显示方式&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
